{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NetBuff NetBuff is a Unity Game Engine based multiplayer engine created as lightweight alternative without the giant overhead of other libraries such as NGO (Netcode for GameObjects) and third-party solutions (like Mirror). This project as first created focusing on our own organization college projects but after a short time this system shown its value and so we put effort on polising and ironing the code to launch it as a an library itself, and here it is! Instalation Guide Go to Unity Package Manager Window -> Package Manager Click the \"+\" button in the upper left corner of the window. Select the \"Add package from git URL...\" option. Paste the link below and click the \"Add\" button. https://github.com/buff-buff-studio/NetBuff-Lib.git#package Supported Transports UDP Local (Supports multiple clients / Split Screen) You can create a custom transporter as well Features Editor/Debugging heavy support Hot-Reload (You can recompile the game without losing the game state) Server Password Protection Server Discovery System Reliable and Unrealiable packets Custom Packet Support Scene Loading / Unloading Credits Scripts by @arnilsenarthur Portability for Package by @SergioMacellani LiteNetLib by RevenantX Serialized Dictionary by ayellowpaper","title":"Home"},{"location":"#netbuff","text":"NetBuff is a Unity Game Engine based multiplayer engine created as lightweight alternative without the giant overhead of other libraries such as NGO (Netcode for GameObjects) and third-party solutions (like Mirror). This project as first created focusing on our own organization college projects but after a short time this system shown its value and so we put effort on polising and ironing the code to launch it as a an library itself, and here it is!","title":"NetBuff"},{"location":"#instalation-guide","text":"Go to Unity Package Manager Window -> Package Manager Click the \"+\" button in the upper left corner of the window. Select the \"Add package from git URL...\" option. Paste the link below and click the \"Add\" button. https://github.com/buff-buff-studio/NetBuff-Lib.git#package","title":"Instalation Guide"},{"location":"#supported-transports","text":"UDP Local (Supports multiple clients / Split Screen) You can create a custom transporter as well","title":"Supported Transports"},{"location":"#features","text":"Editor/Debugging heavy support Hot-Reload (You can recompile the game without losing the game state) Server Password Protection Server Discovery System Reliable and Unrealiable packets Custom Packet Support Scene Loading / Unloading","title":"Features"},{"location":"#credits","text":"Scripts by @arnilsenarthur Portability for Package by @SergioMacellani LiteNetLib by RevenantX Serialized Dictionary by ayellowpaper","title":"Credits"},{"location":"components/","text":"Components The network component structure can be represented as the following image: Network Manager The NetworkManager is the network's main component. It's reponsible to start server, manage connectionsserver, manage objects and sync all the data across the network. Only one NetworkManager shall exist per game. You may create your own implementation of a NetworkManager child class, overriding callbacks to fit your needs. In the network manager you set the current transportation interface, the prefab registry scriptable and the player prefab. You can also set the default server ticking rate, used by NetworkTransforms and NetworkAnimators. For the debugging purposes you can use the Dump Ids button to create a file listing all the registered NetworkIdentities at a given time. Network Identity The NetworkIdentity is the component used by the network to keep object references across the network. Without the identifier the system can't assure that a object in a client view is the \"same\" object at the server environment. A NetworkIdentity does not contain any inspector fields, but shows the NetworkId for debugging purposes. The NetworkId is a 16-characters-long hex string (internally it's represented by two ints) that is used to keep the object reference across the network. You can click at the N button to generate a new id for the object (don't do this if it's not necessary). Ownership Every NetworkIdentity is owned by someone. The field NetworkIdentity.OwnerId is a int that stores the ownership of an object. By default this value is set to -1 (Server Owned). Any other value than -1 represents the id of a client. You can use the bool property NetworkIdentity.IsOwnedByClient to check if a NetworkIdentity is owned by any client. You can use the bool property NetworkIdentity.HasAuthority to check if the NetworkIdentity is owned the local client / local server (if it's host/server). The authority controls who can, by default, modify the NetworkValues related to the NetworkIdentity and who can control the data/state across the network. When you spawn a NetworkIdentity via network you can choose who is the owner of that object. Additionally you can NetworkIdentity.SetOwner (if you have ownership) to transfer a object to another owner: if (!HasAuthority) return; //Transfer the ownership back to the server if(Input.GetKeyDown(KeyCode.S)) SetOwner(-1); Finding Objects There are many methods to locate NetworkIdentity objects. You can use NetworkIdentity.GetNetworkObject to find a NetworkIdentity using it's NetworkId. You can use NetworkIdentity.GetNetworkObjectsOwnedBy to find all the object owned by a given client. Spawning Objects You can spawn new NetworkIdentity objects using the NetworkIdentity.Spawn method using a prefab. But, carefully, you need to register the prefab to the NetworkPrefabRegistry referenced by the NetworkManager: Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true); When you spawn a object you can choose it's ownership and if the object is active or not. By default the OwnerId will be -1 (Server) and the object will be active. Activating / Deactivating Objects You can also toggle the active state of an object. But, instead of using GameObject.active you must use NetworkIdentity.SetActive method. Only the owner of the object can toggle it's activeness, and it will be synced across the network: SetActive(false) Despawning Objects If you need to destroy a NetworkIdentity object you may not use GameObject.Destroy . Instead you need to use NetworkIdentity.Despawn to destroy the object across the network: Despawn(false) Network Behaviour The NetworkBehaviour class is the base class for all network components that are attached to NetworkIdentity objects. It requires the NetworkIdentity component and CAN'T be added / removed from a object at runtime. Almost all the logic of your project that requires network will be writen implementing this class. Network Transform The NetworkTransform is one of the standard basic NetworkBehaviours. It's used to sync a object transform state. You can customize the rate and which fields will be sync across the network (saving data transfer rate): You shall not change the NetworkTransform.SyncMode runtime. The thresholds determines when a transform should be re-synced or not. If the tick rate is set to -1, the NetworkManager tick rate will be used. Network Rigidbody Transform The NetworkRigidbodyTransform works similiar to its base class NetworkTransform, but it also syncs the velocity and angular velocity fields. This component requires the Rigidbody component. You shall not change the NetworkTransform.SyncMode runtime. The thresholds determines when a transform should be re-synced or not. If the tick rate is set to -1, the NetworkManager tick rate will be used. Network Animator The NetworkAnimator, as the name implies, is used to sync the state of an Animator. This component will sync parameters, layer weights and animation/transition timings: You shall use the NetworkAnimator.SetTrigger instead of the Animator.SetTrigger cause triggers don't save any state, so the system cannot detect changes in them. All other parameter types will sync automatically. Network Values The first (and the most simple) way to customize your NetworkBehaviours is using NetworkValues. The list bellow shows all the supported value types. You can add support to your custom type as well, using serialization and deserialization. Bool Byte Int Float Double Long Short String Vector2 Vector3 Vector4 Quaternion Color NetworkId public class CustomBehaviour : NetworkBehaviour { //Only the NetworkIdentity owner can modify this value public ColorNetworkValue color = new ColorNetworkValue(Color.white); //Only the server can modifiy this value public IntNetworkValue team = new IntNetworkValue(2, NetworkValue.ModifierType.Server); private void OnEnable() { //Register values WithValues(color, team); } private void Update() { if(!HasAuthority) return; if(Input.GetKeyDown(KeyCode.Space)) team.Value ++; } } Network values will be shown yellow in the inspector. For testing purposes, any NetworkValue can be modified in the Inspector, even if you don't have permission do change it. Listening For Changes The NetworkValue<> base class has an OnValueChanged callback that is called when the value is updated (locally or externally). It's very useful while creating reactive systems (like a player that changes the color if his team changes). You can see another usage bellow: public class PlayerController : NetworkBehaviour { public StringNetworkValue nickname = new StringNetworkValue(\"\"); public TMP_Text headPlate; public void OnEnable() { WithValues(nickname); nickname.OnValueChanged += (oldValue, newValue) => { headPlate.text = newValue; }; } }","title":"Components"},{"location":"components/#components","text":"The network component structure can be represented as the following image:","title":"Components"},{"location":"components/#network-manager","text":"The NetworkManager is the network's main component. It's reponsible to start server, manage connectionsserver, manage objects and sync all the data across the network. Only one NetworkManager shall exist per game. You may create your own implementation of a NetworkManager child class, overriding callbacks to fit your needs. In the network manager you set the current transportation interface, the prefab registry scriptable and the player prefab. You can also set the default server ticking rate, used by NetworkTransforms and NetworkAnimators. For the debugging purposes you can use the Dump Ids button to create a file listing all the registered NetworkIdentities at a given time.","title":"Network Manager"},{"location":"components/#network-identity","text":"The NetworkIdentity is the component used by the network to keep object references across the network. Without the identifier the system can't assure that a object in a client view is the \"same\" object at the server environment. A NetworkIdentity does not contain any inspector fields, but shows the NetworkId for debugging purposes. The NetworkId is a 16-characters-long hex string (internally it's represented by two ints) that is used to keep the object reference across the network. You can click at the N button to generate a new id for the object (don't do this if it's not necessary).","title":"Network Identity"},{"location":"components/#ownership","text":"Every NetworkIdentity is owned by someone. The field NetworkIdentity.OwnerId is a int that stores the ownership of an object. By default this value is set to -1 (Server Owned). Any other value than -1 represents the id of a client. You can use the bool property NetworkIdentity.IsOwnedByClient to check if a NetworkIdentity is owned by any client. You can use the bool property NetworkIdentity.HasAuthority to check if the NetworkIdentity is owned the local client / local server (if it's host/server). The authority controls who can, by default, modify the NetworkValues related to the NetworkIdentity and who can control the data/state across the network. When you spawn a NetworkIdentity via network you can choose who is the owner of that object. Additionally you can NetworkIdentity.SetOwner (if you have ownership) to transfer a object to another owner: if (!HasAuthority) return; //Transfer the ownership back to the server if(Input.GetKeyDown(KeyCode.S)) SetOwner(-1);","title":"Ownership"},{"location":"components/#finding-objects","text":"There are many methods to locate NetworkIdentity objects. You can use NetworkIdentity.GetNetworkObject to find a NetworkIdentity using it's NetworkId. You can use NetworkIdentity.GetNetworkObjectsOwnedBy to find all the object owned by a given client.","title":"Finding Objects"},{"location":"components/#spawning-objects","text":"You can spawn new NetworkIdentity objects using the NetworkIdentity.Spawn method using a prefab. But, carefully, you need to register the prefab to the NetworkPrefabRegistry referenced by the NetworkManager: Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true); When you spawn a object you can choose it's ownership and if the object is active or not. By default the OwnerId will be -1 (Server) and the object will be active.","title":"Spawning Objects"},{"location":"components/#activating-deactivating-objects","text":"You can also toggle the active state of an object. But, instead of using GameObject.active you must use NetworkIdentity.SetActive method. Only the owner of the object can toggle it's activeness, and it will be synced across the network: SetActive(false)","title":"Activating / Deactivating Objects"},{"location":"components/#despawning-objects","text":"If you need to destroy a NetworkIdentity object you may not use GameObject.Destroy . Instead you need to use NetworkIdentity.Despawn to destroy the object across the network: Despawn(false)","title":"Despawning Objects"},{"location":"components/#network-behaviour","text":"The NetworkBehaviour class is the base class for all network components that are attached to NetworkIdentity objects. It requires the NetworkIdentity component and CAN'T be added / removed from a object at runtime. Almost all the logic of your project that requires network will be writen implementing this class.","title":"Network Behaviour"},{"location":"components/#network-transform","text":"The NetworkTransform is one of the standard basic NetworkBehaviours. It's used to sync a object transform state. You can customize the rate and which fields will be sync across the network (saving data transfer rate): You shall not change the NetworkTransform.SyncMode runtime. The thresholds determines when a transform should be re-synced or not. If the tick rate is set to -1, the NetworkManager tick rate will be used.","title":"Network Transform"},{"location":"components/#network-rigidbody-transform","text":"The NetworkRigidbodyTransform works similiar to its base class NetworkTransform, but it also syncs the velocity and angular velocity fields. This component requires the Rigidbody component. You shall not change the NetworkTransform.SyncMode runtime. The thresholds determines when a transform should be re-synced or not. If the tick rate is set to -1, the NetworkManager tick rate will be used.","title":"Network Rigidbody Transform"},{"location":"components/#network-animator","text":"The NetworkAnimator, as the name implies, is used to sync the state of an Animator. This component will sync parameters, layer weights and animation/transition timings: You shall use the NetworkAnimator.SetTrigger instead of the Animator.SetTrigger cause triggers don't save any state, so the system cannot detect changes in them. All other parameter types will sync automatically.","title":"Network Animator"},{"location":"components/#network-values","text":"The first (and the most simple) way to customize your NetworkBehaviours is using NetworkValues. The list bellow shows all the supported value types. You can add support to your custom type as well, using serialization and deserialization. Bool Byte Int Float Double Long Short String Vector2 Vector3 Vector4 Quaternion Color NetworkId public class CustomBehaviour : NetworkBehaviour { //Only the NetworkIdentity owner can modify this value public ColorNetworkValue color = new ColorNetworkValue(Color.white); //Only the server can modifiy this value public IntNetworkValue team = new IntNetworkValue(2, NetworkValue.ModifierType.Server); private void OnEnable() { //Register values WithValues(color, team); } private void Update() { if(!HasAuthority) return; if(Input.GetKeyDown(KeyCode.Space)) team.Value ++; } } Network values will be shown yellow in the inspector. For testing purposes, any NetworkValue can be modified in the Inspector, even if you don't have permission do change it.","title":"Network Values"},{"location":"components/#listening-for-changes","text":"The NetworkValue<> base class has an OnValueChanged callback that is called when the value is updated (locally or externally). It's very useful while creating reactive systems (like a player that changes the color if his team changes). You can see another usage bellow: public class PlayerController : NetworkBehaviour { public StringNetworkValue nickname = new StringNetworkValue(\"\"); public TMP_Text headPlate; public void OnEnable() { WithValues(nickname); nickname.OnValueChanged += (oldValue, newValue) => { headPlate.text = newValue; }; } }","title":"Listening For Changes"},{"location":"custom_behaviours/","text":"Creating Custom Behaviours In the following sections you can find help on how to implement you own NetworkBehaviours, overriding its network callbacks. The basic structure of a NetworkBehaviour is shown bellow: public class CustomNetworkBehaviour : NetworkBehaviour { //My Fields public float walkSpeed = 3f; //My Network Values public IntNetworkValue team = new IntNetworkValue(0); //Unity callbacks public void OnEnable(){} //Network callbacks public override void OnSpawned(bool isRetroactive){} } There's no special rules, it works exactly like a normal MonoBehaviour, while providing network communication/syncing and the power to change the behaviour of a NetworkIdentity object Custom Serialization If your class has a complex (or even variable data structure) that is too complex to be synced via NetworkValues you can use the custom serialization system. All you need to do is using the interface INetworkBehaviourSerializer : public class CustomNetworkBehaviour : NetworkBehaviour, INetworkBehaviourSerializer { public float[] valueTooComplex = new float[0]; public void OnSerialize(BinaryWriter writer, bool forceSendAll) { writer.Write(valueTooComplex.Length); for (var i = 0; i < valueTooComplex.Length; i++) { writer.Write(valueTooComplex[i]); } } public void OnDeserialize(BinaryReader reader) { var length = reader.ReadInt32(); valueTooComplex = new float[length]; for (var i = 0; i < length; i++) { valueTooComplex[i] = reader.ReadSingle(); } } } Doing this, all the data will be synced through the network (even for late-joiners). If your data is too complex you can implement a system to only update the needed data, but when forceSendAll is true you need to write all the data to the writer. This value will be true when a late joiner is requesting all NetworkIdentities data. You can use NetworkIdentity.MarkSerializerDirty to call the OnSerialize method, so the OnSerialize (with forceSendAll = false) will be called again and the data will be synced, so the other network peers will use OnDeserialize to read the data. Custom Packets The third method to create custom data transfer / syncing is using packets. Internally, all the three methods end up using Packets to send data through the network, but you can create your custom own packets. The packet system was chosen was the main transfer method of NetBuff as packets are super fast, easy-to-use and lightweight while comparated to other solutions. To create a custom packet you need to create a new class that implements the IPacket or the IOwnedPacket interface: public class PlayerPunchActionPacket : IPacket { public NetworkId Id { get; set; } public void Serialize(BinaryWriter writer) { Id.Serialize(writer); } public void Deserialize(BinaryReader reader) { Id = NetworkId.Read(reader); } } public class PacketBodyRotation : IOwnedPacket { public NetworkId Id { get; set; } public float BodyRotation { get; set; } public void Serialize(BinaryWriter writer) { Id.Serialize(writer); writer.Write(BodyRotation); } public void Deserialize(BinaryReader reader) { Id = NetworkId.Read(reader); BodyRotation = reader.ReadSingle(); } } A IOwnedPacket is a IPacket that is directly attached to a NetworkIdentity, so they will be sent internally by a NetworkBehaviour and the server will find the same NetworkBehaviour at the other network peers and call the receiving callback. A normal IPacket is not directly attached to anything, so they will just sent through the network and all the handling must be done manually. Sending Packets To send a packet you can use the SendPacket method that will automatically use the correct method to send the packet: var packet = new PacketBodyRotation { Id = Id, BodyRotation = body.localEulerAngles.y }; SendPacket(packet); Internally the SendPacket method uses the NetworkBehaviour.ClientSendPacket and NetworkBehaviour.ServerBroadcastPacket methods, so you can use them as well: if (IsOwnedByClient) ClientSendPacket(packet, reliable); //Client sends a message to the server else ServerBroadcastPacket(packet, reliable); //Server broadcast a message to all the clients If you are on the server side you can use NetworkBehaviour.ServerBroadcastPacketExceptFor to broadcast a message to all the clients except one. This behaviour can be useful sometimes. Packet Reliability When you use any of the packet sending methods you can set the argument of reliabity. When set to true the delivery method is reliable, supports larger packets with the cost of being a little slower. When the value is set to false there no realibity, packets are limited to small sizes but the delivery is blazing fast! NetworkValue syncing and any other important/instant action are made using reliable delivery, as they need to be guaranteed to delivered. NetworkTransform in the other side don't use the reliability delivery, as their state is almost constantly updated, so losing some packets will probably not cause an issue. The packet loss count can be seen using the NetworkManagerGUI. If the network connection quality is good you may not lose a single packet, but if you have network issues you may experience some packet loss. Choose wisely when the reliability is needed or not. Most of the time the reliable=true is the way to go. Unreliable Reliable Speed Fast+ Fast Max Size Small Large Order May be unordered The order will be kept Loss May be lost If lost they will be sent again usage Example NetworkTransform, high-freq update packets Actions, NetworkValues, etc... Receiving Owned Packets To receive IOwnedPackets we can use the NetworkBehaviour.OnServerReceivePacket and NetworkBehaviour.OnClientReceivePacket callbacks: public class PlayerController : NetworkBehaviour { //Server received the packet, check the ownership (optional) than broadcasts it to everyone else than the origin client public override void OnServerReceivePacket(IOwnedPacket packet, int clientId) { switch (packet) { case PacketBodyRotation data: if(clientId == OwnerId) ServerBroadcastPacketExceptFor(data, clientId); break; } } //Client received the packet, then applied it to the transform itslf public override void OnClientReceivePacket(IOwnedPacket packet) { switch (packet) { case PacketBodyRotation bodyRot: transform.eulerAngles = new Vector3(0, bodyRot.BodyRotation, 0); break; } } } Only the object with the IOwnedPacket id will receive the callbacks, so you don't need to worry checking the id manually! Receiving Not Owned / Any Packets If a packet is not owned you can register a custom listener for it anywhere in the project. In the example bellow the Lever class is listening for PlayerPunchActionPacket, which is a packet that is sent by the PlayerController class: public class Lever : NetworkBehaviour { public BoolNetworkValue isOn = new(false); public float radius = 2f; private void OnEnable() { WithValues(isOn); GetPacketListener<PlayerPunchActionPacket>().OnServerReceive += OnPlayerPunch; //GetPacketListener<PlayerPunchActionPacket>().OnClientReceive ...; } private void OnDisable() { GetPacketListener<PlayerPunchActionPacket>().OnServerReceive -= OnPlayerPunch; } private void OnPlayerPunch(PlayerPunchActionPacket obj, int client) { var o = GetNetworkObject(obj.Id); var dist = Vector3.Distance(o.transform.position, transform.position); if (dist > radius) return; isOn.Value = !isOn.Value; } } public class PlayerController : NetworkBehaviour { private void Update() { if (!HasAuthority) return; if (Input.GetKeyDown(KeyCode.Q)) { SendPacket(new PlayerPunchActionPacket { Id = Id }, true); } } } You can use the NetworkBehaviour.GetPacketListener to listen to IOwnedPackets as well. Network Callbacks In the table bellow you can find a list of all the NetworkBehaviour class callbacks: Name Parameters Description OnServerReceivePacket IOwnedPacket packet int clientId Called when the server side object receives an IOwnedPacket (Called on host as well) OnClientReceivePacket IOwnedPacket packet Called when the client side object receives and IOwnedPacket (Called on host as well) OnSpawned bool isRetroactive Called in the first frame that a NetworkIdentity object exists into the network. isRetroactive will be true for late-joiners syncing purposes OnSceneChanged int fromScene int toScene Called when the object is moved from one scene to another OnClientConnected int clientId Called when a client connect to the server (Called only on server) OnClientDisconnected int clientId Called when a client disconnect from the server (Called only on server) OnDespawned Called when a NetworkIdentiy object is despawned OnActiveChanged bool active Called when the activeness of a NetworkIdentity object changes OnOwnershipChanged int oldOwner int newOwner Called when the ownership of a NetworkIdentity object changes You can use any Unity callback normally as a NetworkBehaviour is also a MonoBehaviour.","title":"Creating Custom Behaviours"},{"location":"custom_behaviours/#creating-custom-behaviours","text":"In the following sections you can find help on how to implement you own NetworkBehaviours, overriding its network callbacks. The basic structure of a NetworkBehaviour is shown bellow: public class CustomNetworkBehaviour : NetworkBehaviour { //My Fields public float walkSpeed = 3f; //My Network Values public IntNetworkValue team = new IntNetworkValue(0); //Unity callbacks public void OnEnable(){} //Network callbacks public override void OnSpawned(bool isRetroactive){} } There's no special rules, it works exactly like a normal MonoBehaviour, while providing network communication/syncing and the power to change the behaviour of a NetworkIdentity object","title":"Creating Custom Behaviours"},{"location":"custom_behaviours/#custom-serialization","text":"If your class has a complex (or even variable data structure) that is too complex to be synced via NetworkValues you can use the custom serialization system. All you need to do is using the interface INetworkBehaviourSerializer : public class CustomNetworkBehaviour : NetworkBehaviour, INetworkBehaviourSerializer { public float[] valueTooComplex = new float[0]; public void OnSerialize(BinaryWriter writer, bool forceSendAll) { writer.Write(valueTooComplex.Length); for (var i = 0; i < valueTooComplex.Length; i++) { writer.Write(valueTooComplex[i]); } } public void OnDeserialize(BinaryReader reader) { var length = reader.ReadInt32(); valueTooComplex = new float[length]; for (var i = 0; i < length; i++) { valueTooComplex[i] = reader.ReadSingle(); } } } Doing this, all the data will be synced through the network (even for late-joiners). If your data is too complex you can implement a system to only update the needed data, but when forceSendAll is true you need to write all the data to the writer. This value will be true when a late joiner is requesting all NetworkIdentities data. You can use NetworkIdentity.MarkSerializerDirty to call the OnSerialize method, so the OnSerialize (with forceSendAll = false) will be called again and the data will be synced, so the other network peers will use OnDeserialize to read the data.","title":"Custom Serialization"},{"location":"custom_behaviours/#custom-packets","text":"The third method to create custom data transfer / syncing is using packets. Internally, all the three methods end up using Packets to send data through the network, but you can create your custom own packets. The packet system was chosen was the main transfer method of NetBuff as packets are super fast, easy-to-use and lightweight while comparated to other solutions. To create a custom packet you need to create a new class that implements the IPacket or the IOwnedPacket interface: public class PlayerPunchActionPacket : IPacket { public NetworkId Id { get; set; } public void Serialize(BinaryWriter writer) { Id.Serialize(writer); } public void Deserialize(BinaryReader reader) { Id = NetworkId.Read(reader); } } public class PacketBodyRotation : IOwnedPacket { public NetworkId Id { get; set; } public float BodyRotation { get; set; } public void Serialize(BinaryWriter writer) { Id.Serialize(writer); writer.Write(BodyRotation); } public void Deserialize(BinaryReader reader) { Id = NetworkId.Read(reader); BodyRotation = reader.ReadSingle(); } } A IOwnedPacket is a IPacket that is directly attached to a NetworkIdentity, so they will be sent internally by a NetworkBehaviour and the server will find the same NetworkBehaviour at the other network peers and call the receiving callback. A normal IPacket is not directly attached to anything, so they will just sent through the network and all the handling must be done manually.","title":"Custom Packets"},{"location":"custom_behaviours/#sending-packets","text":"To send a packet you can use the SendPacket method that will automatically use the correct method to send the packet: var packet = new PacketBodyRotation { Id = Id, BodyRotation = body.localEulerAngles.y }; SendPacket(packet); Internally the SendPacket method uses the NetworkBehaviour.ClientSendPacket and NetworkBehaviour.ServerBroadcastPacket methods, so you can use them as well: if (IsOwnedByClient) ClientSendPacket(packet, reliable); //Client sends a message to the server else ServerBroadcastPacket(packet, reliable); //Server broadcast a message to all the clients If you are on the server side you can use NetworkBehaviour.ServerBroadcastPacketExceptFor to broadcast a message to all the clients except one. This behaviour can be useful sometimes.","title":"Sending Packets"},{"location":"custom_behaviours/#packet-reliability","text":"When you use any of the packet sending methods you can set the argument of reliabity. When set to true the delivery method is reliable, supports larger packets with the cost of being a little slower. When the value is set to false there no realibity, packets are limited to small sizes but the delivery is blazing fast! NetworkValue syncing and any other important/instant action are made using reliable delivery, as they need to be guaranteed to delivered. NetworkTransform in the other side don't use the reliability delivery, as their state is almost constantly updated, so losing some packets will probably not cause an issue. The packet loss count can be seen using the NetworkManagerGUI. If the network connection quality is good you may not lose a single packet, but if you have network issues you may experience some packet loss. Choose wisely when the reliability is needed or not. Most of the time the reliable=true is the way to go. Unreliable Reliable Speed Fast+ Fast Max Size Small Large Order May be unordered The order will be kept Loss May be lost If lost they will be sent again usage Example NetworkTransform, high-freq update packets Actions, NetworkValues, etc...","title":"Packet Reliability"},{"location":"custom_behaviours/#receiving-owned-packets","text":"To receive IOwnedPackets we can use the NetworkBehaviour.OnServerReceivePacket and NetworkBehaviour.OnClientReceivePacket callbacks: public class PlayerController : NetworkBehaviour { //Server received the packet, check the ownership (optional) than broadcasts it to everyone else than the origin client public override void OnServerReceivePacket(IOwnedPacket packet, int clientId) { switch (packet) { case PacketBodyRotation data: if(clientId == OwnerId) ServerBroadcastPacketExceptFor(data, clientId); break; } } //Client received the packet, then applied it to the transform itslf public override void OnClientReceivePacket(IOwnedPacket packet) { switch (packet) { case PacketBodyRotation bodyRot: transform.eulerAngles = new Vector3(0, bodyRot.BodyRotation, 0); break; } } } Only the object with the IOwnedPacket id will receive the callbacks, so you don't need to worry checking the id manually!","title":"Receiving Owned Packets"},{"location":"custom_behaviours/#receiving-not-owned-any-packets","text":"If a packet is not owned you can register a custom listener for it anywhere in the project. In the example bellow the Lever class is listening for PlayerPunchActionPacket, which is a packet that is sent by the PlayerController class: public class Lever : NetworkBehaviour { public BoolNetworkValue isOn = new(false); public float radius = 2f; private void OnEnable() { WithValues(isOn); GetPacketListener<PlayerPunchActionPacket>().OnServerReceive += OnPlayerPunch; //GetPacketListener<PlayerPunchActionPacket>().OnClientReceive ...; } private void OnDisable() { GetPacketListener<PlayerPunchActionPacket>().OnServerReceive -= OnPlayerPunch; } private void OnPlayerPunch(PlayerPunchActionPacket obj, int client) { var o = GetNetworkObject(obj.Id); var dist = Vector3.Distance(o.transform.position, transform.position); if (dist > radius) return; isOn.Value = !isOn.Value; } } public class PlayerController : NetworkBehaviour { private void Update() { if (!HasAuthority) return; if (Input.GetKeyDown(KeyCode.Q)) { SendPacket(new PlayerPunchActionPacket { Id = Id }, true); } } } You can use the NetworkBehaviour.GetPacketListener to listen to IOwnedPackets as well.","title":"Receiving Not Owned / Any Packets"},{"location":"custom_behaviours/#network-callbacks","text":"In the table bellow you can find a list of all the NetworkBehaviour class callbacks: Name Parameters Description OnServerReceivePacket IOwnedPacket packet int clientId Called when the server side object receives an IOwnedPacket (Called on host as well) OnClientReceivePacket IOwnedPacket packet Called when the client side object receives and IOwnedPacket (Called on host as well) OnSpawned bool isRetroactive Called in the first frame that a NetworkIdentity object exists into the network. isRetroactive will be true for late-joiners syncing purposes OnSceneChanged int fromScene int toScene Called when the object is moved from one scene to another OnClientConnected int clientId Called when a client connect to the server (Called only on server) OnClientDisconnected int clientId Called when a client disconnect from the server (Called only on server) OnDespawned Called when a NetworkIdentiy object is despawned OnActiveChanged bool active Called when the activeness of a NetworkIdentity object changes OnOwnershipChanged int oldOwner int newOwner Called when the ownership of a NetworkIdentity object changes You can use any Unity callback normally as a NetworkBehaviour is also a MonoBehaviour.","title":"Network Callbacks"},{"location":"custom_network_manager/","text":"Custom Network Manager Sometimes the default network manager implementation may not fullfil all your needs. We recommend you to create your own implementation of the NetworkManager to fit your project needs. In the following example theres a custom NetworkManager implementation where we override the NetworkManager.OnSpawnPlayer method to fit our probject (Solis) needs: public class SolisNetworkManager : NetworkManager { public GameObject robotPrefab; public Transform robotSpawnPoint; public Transform humanSpawnPoint; private void Awake() { if (Instance == this || Instance == null) DontDestroyOnLoad(this.gameObject); else Destroy(this.gameObject); } protected override void OnSpawnPlayer(int clientId) { var prefab = clientId == 0 ? playerPrefab : robotPrefab; var t = clientId == 0 ? humanSpawnPoint : robotSpawnPoint; Assert.IsTrue(prefabRegistry.IsPrefabValid(prefab), \"Player prefab is not valid\"); SpawnNetworkObjectForClients(prefabRegistry.GetPrefabId(prefab), t.position, t.rotation, t.localScale, clientId); } } Callbacks In the list bellow you can find all the methods that you can customize to fit your project: Name Parameters Description OnServerStart Called when the server stats (Server Only) OnServerStop Called when the server stops (Server Only) OnNetworkObjectSpawned NetworkIdentity identity bool retroactive Called when a NetworkIdentity object spawns OnNetworkObjectDespawned NetworkIdentity identity Called right before a NetworkIdentity object despawn OnClientConnected int clientId Called when a client joins the server (Server Only) OnClientDisconnected int clientId string reason Called when a client leaves the server (Server Only) OnSpawnPlayer int clientId Called by the server when a client joins to spawn the player object (Server Only) OnConnect Called when the client joins the server (Client Only) OnDisconnect string reason Called when the client leaves the server (Client Only) OnServerReceivePacket int clientId IPacket packet Called when the server receives a packet (Server Only) OnClientReceivePacket IPacket packet Called when the client receives a packet (Client Only) OnClearEnvironment Called after the server stop / client disconnection to clear the main scene to it's initial state","title":"Custom Network Manager"},{"location":"custom_network_manager/#custom-network-manager","text":"Sometimes the default network manager implementation may not fullfil all your needs. We recommend you to create your own implementation of the NetworkManager to fit your project needs. In the following example theres a custom NetworkManager implementation where we override the NetworkManager.OnSpawnPlayer method to fit our probject (Solis) needs: public class SolisNetworkManager : NetworkManager { public GameObject robotPrefab; public Transform robotSpawnPoint; public Transform humanSpawnPoint; private void Awake() { if (Instance == this || Instance == null) DontDestroyOnLoad(this.gameObject); else Destroy(this.gameObject); } protected override void OnSpawnPlayer(int clientId) { var prefab = clientId == 0 ? playerPrefab : robotPrefab; var t = clientId == 0 ? humanSpawnPoint : robotSpawnPoint; Assert.IsTrue(prefabRegistry.IsPrefabValid(prefab), \"Player prefab is not valid\"); SpawnNetworkObjectForClients(prefabRegistry.GetPrefabId(prefab), t.position, t.rotation, t.localScale, clientId); } }","title":"Custom Network Manager"},{"location":"custom_network_manager/#callbacks","text":"In the list bellow you can find all the methods that you can customize to fit your project: Name Parameters Description OnServerStart Called when the server stats (Server Only) OnServerStop Called when the server stops (Server Only) OnNetworkObjectSpawned NetworkIdentity identity bool retroactive Called when a NetworkIdentity object spawns OnNetworkObjectDespawned NetworkIdentity identity Called right before a NetworkIdentity object despawn OnClientConnected int clientId Called when a client joins the server (Server Only) OnClientDisconnected int clientId string reason Called when a client leaves the server (Server Only) OnSpawnPlayer int clientId Called by the server when a client joins to spawn the player object (Server Only) OnConnect Called when the client joins the server (Client Only) OnDisconnect string reason Called when the client leaves the server (Client Only) OnServerReceivePacket int clientId IPacket packet Called when the server receives a packet (Server Only) OnClientReceivePacket IPacket packet Called when the client receives a packet (Client Only) OnClearEnvironment Called after the server stop / client disconnection to clear the main scene to it's initial state","title":"Callbacks"},{"location":"getting_started/","text":"Getting Started In the following sections you can find help on how to setup a NetLib project. We recommend using unity 2023.2 or a newer version. Package Installation Go to Unity Package Manager Window -> Package Manager Click the \"+\" button in the upper left corner of the window. Select the \"Add package from git URL...\" option. Paste the link below and click the \"Add\" button. Done! Now the package is already installed. You can download samples as well if you want https://github.com/buff-buff-studio/NetBuff-Lib.git#package Networking Setup Create a empty scene to begin. We recommend using the Basic (Built-In) template: Now, create a new GameObject and add the following components: Network Manager Network Manager GUI UDP Network Transport Network Manager The NetworkManager is the main network component. It manages conections, objects, packets and everything else network-related, being an unique component in the network structure. Network Manager GUI The NetworkManagerGUI is a temporary component used for testing purposes. It creates a menu where you can manage the network connection, find all the servers on the network and to see network stats UDP Network Transport The UDPNetworkTransport is the basic transport, used to establish server-client connections over internet Set Network Transport Now we need to set the network transport at the network manager. Just drag and drop the transport into the manager transport field: Creating the player prefab If you start the game and try to host a server you will see an error in console. By default we need to provide a player prefab to the NetworkManager to spawn the player object. Following the steps bellow we can create a simple player prefab: Create a new capsule Add a NetworkTransform component Drop it as a prefab at the Project View Delete it from the scene Creating the prefab registry Now you are one step away from the success! Even if you set the player prefab, all the network ends must know what the prefab the server is trying to spawn, so we need to setup our NetworkPrefabRegistry first. Create a new NetworkPrefabRegistry in the left click menu of the Project Folder Add the prefab to the registry list (Create at the + button to add a new slot to the registry) Click on N button to generate a new id Set it in the registry field of the NetworkManager Set the player prefab in the player prefab field of the NetworkManager Done! Now we are done! You can hit the play button and then click in Start Host to start the host (Client + Server) Simple Movement Test Creating a simple script we can test our server. You can use the code bellow or create your own logic! using NetBuff.Components; using UnityEngine; namespace Samples.Docs { public class BasicMovement : NetworkBehaviour { private void Update() { if (!HasAuthority) return; var move = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\")); transform.position += move * Time.deltaTime * 3; } } } Add it to player and run the game again! You can even build and join the server as client because your multiplayer game is already working!","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In the following sections you can find help on how to setup a NetLib project. We recommend using unity 2023.2 or a newer version.","title":"Getting Started"},{"location":"getting_started/#package-installation","text":"Go to Unity Package Manager Window -> Package Manager Click the \"+\" button in the upper left corner of the window. Select the \"Add package from git URL...\" option. Paste the link below and click the \"Add\" button. Done! Now the package is already installed. You can download samples as well if you want https://github.com/buff-buff-studio/NetBuff-Lib.git#package","title":"Package Installation"},{"location":"getting_started/#networking-setup","text":"Create a empty scene to begin. We recommend using the Basic (Built-In) template: Now, create a new GameObject and add the following components: Network Manager Network Manager GUI UDP Network Transport","title":"Networking Setup"},{"location":"getting_started/#network-manager","text":"The NetworkManager is the main network component. It manages conections, objects, packets and everything else network-related, being an unique component in the network structure.","title":"Network Manager"},{"location":"getting_started/#network-manager-gui","text":"The NetworkManagerGUI is a temporary component used for testing purposes. It creates a menu where you can manage the network connection, find all the servers on the network and to see network stats","title":"Network Manager GUI"},{"location":"getting_started/#udp-network-transport","text":"The UDPNetworkTransport is the basic transport, used to establish server-client connections over internet","title":"UDP Network Transport"},{"location":"getting_started/#set-network-transport","text":"Now we need to set the network transport at the network manager. Just drag and drop the transport into the manager transport field:","title":"Set Network Transport"},{"location":"getting_started/#creating-the-player-prefab","text":"If you start the game and try to host a server you will see an error in console. By default we need to provide a player prefab to the NetworkManager to spawn the player object. Following the steps bellow we can create a simple player prefab: Create a new capsule Add a NetworkTransform component Drop it as a prefab at the Project View Delete it from the scene","title":"Creating the player prefab"},{"location":"getting_started/#creating-the-prefab-registry","text":"Now you are one step away from the success! Even if you set the player prefab, all the network ends must know what the prefab the server is trying to spawn, so we need to setup our NetworkPrefabRegistry first. Create a new NetworkPrefabRegistry in the left click menu of the Project Folder Add the prefab to the registry list (Create at the + button to add a new slot to the registry) Click on N button to generate a new id Set it in the registry field of the NetworkManager Set the player prefab in the player prefab field of the NetworkManager","title":"Creating the prefab registry"},{"location":"getting_started/#done","text":"Now we are done! You can hit the play button and then click in Start Host to start the host (Client + Server)","title":"Done!"},{"location":"getting_started/#simple-movement-test","text":"Creating a simple script we can test our server. You can use the code bellow or create your own logic! using NetBuff.Components; using UnityEngine; namespace Samples.Docs { public class BasicMovement : NetworkBehaviour { private void Update() { if (!HasAuthority) return; var move = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\")); transform.position += move * Time.deltaTime * 3; } } } Add it to player and run the game again! You can even build and join the server as client because your multiplayer game is already working!","title":"Simple Movement Test"},{"location":"network_testing/","text":"Testing the Network We commeding using the package Multiplayer Player Mode to test your game in the editor with no need to generate a build every single time. If you want you can also just generate a build and run it as well. With the hot-reload system you can edit your code in real time and your server state will be kept with no problems, so you can tweak values or test / debug systems without the needing of rebuilding your project every single time. The default NetBuff transport method is UDP. Using the UDPNetworkTransport you can test your game connecting multiples clients (editors and builds) with just one click! We recommend using the Clumsy to simulate lag and packet loss between your network connections to see where your projects need more optimization / clean up. Clumsy is a free tool that can simulate lag, packet drops, out of order delivery and much more: Using the out of order / packet drop feature you can check if some your packets that is been sent in a unreliable way should be changed to the reliable method and to check if there's any issue in the network state syncing.","title":"Testing the Network"},{"location":"network_testing/#testing-the-network","text":"We commeding using the package Multiplayer Player Mode to test your game in the editor with no need to generate a build every single time. If you want you can also just generate a build and run it as well. With the hot-reload system you can edit your code in real time and your server state will be kept with no problems, so you can tweak values or test / debug systems without the needing of rebuilding your project every single time. The default NetBuff transport method is UDP. Using the UDPNetworkTransport you can test your game connecting multiples clients (editors and builds) with just one click! We recommend using the Clumsy to simulate lag and packet loss between your network connections to see where your projects need more optimization / clean up. Clumsy is a free tool that can simulate lag, packet drops, out of order delivery and much more: Using the out of order / packet drop feature you can check if some your packets that is been sent in a unreliable way should be changed to the reliable method and to check if there's any issue in the network state syncing.","title":"Testing the Network"},{"location":"object_spawning/","text":"Spawning Objects There are two types of NetworkIdentity objects: pre-existing and realtime-spawned. Using the field NetworkIdentity.PrefabId you can check if a object is pre-existing or not. If the PrefabId is empty the object was not spawned in real time. Otherwise the PrefabId will store the NetworkId of the prefab used to create that object. It's very important for the server to know how to recreate the server state when a late-joiner joins the server. You can spawn NetworkObjects using the NetworkIdentity.SpawnObject static method: if(Input.GetMouseButtonDown(0)) { Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true); } And done! With one line of code your game object is spawned all across the network. Just remember to check if your prefab is registered into the NetworkPacketRegistry. You can also use the NetBuff/Check Prefab Registries if there's any problem with your registries: Spawning Parameters In the list bellow you can find all the parameters you can set in a NetworkIdentity object spawning: Parameter Type Description Owner int Represents the ownership id of the object. Default is -1 (Server) Position Vector3 Object world position Rotation Quaternion Object world rotation Scale Vector3 Object scale Active bool Object activeness state Scene int Represents the target scene id. Default is -1 (Last Loaded Scene) The scene id is the only complex one. By default it's set to -1, so the NetworkIdentity object will spawn in the current last loaded scene. If the value is set to any other value it will be set to the correspondent loaded scene. The scene id 0 will always point to the main scene, where the NetworkManager is located.","title":"Spawning Objects"},{"location":"object_spawning/#spawning-objects","text":"There are two types of NetworkIdentity objects: pre-existing and realtime-spawned. Using the field NetworkIdentity.PrefabId you can check if a object is pre-existing or not. If the PrefabId is empty the object was not spawned in real time. Otherwise the PrefabId will store the NetworkId of the prefab used to create that object. It's very important for the server to know how to recreate the server state when a late-joiner joins the server. You can spawn NetworkObjects using the NetworkIdentity.SpawnObject static method: if(Input.GetMouseButtonDown(0)) { Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true); } And done! With one line of code your game object is spawned all across the network. Just remember to check if your prefab is registered into the NetworkPacketRegistry. You can also use the NetBuff/Check Prefab Registries if there's any problem with your registries:","title":"Spawning Objects"},{"location":"object_spawning/#spawning-parameters","text":"In the list bellow you can find all the parameters you can set in a NetworkIdentity object spawning: Parameter Type Description Owner int Represents the ownership id of the object. Default is -1 (Server) Position Vector3 Object world position Rotation Quaternion Object world rotation Scale Vector3 Object scale Active bool Object activeness state Scene int Represents the target scene id. Default is -1 (Last Loaded Scene) The scene id is the only complex one. By default it's set to -1, so the NetworkIdentity object will spawn in the current last loaded scene. If the value is set to any other value it will be set to the correspondent loaded scene. The scene id 0 will always point to the main scene, where the NetworkManager is located.","title":"Spawning Parameters"},{"location":"reconnection_and_hot_reload/","text":"Reconnection And Hot Reload NetBuff supports mid/late-game connections with no problems: Every single NetworkIdentity from every single scene will be synced, within it's values and it's additional serialized data. Even on editor, you can edit the code, recompile the project and the server will keep it's state with no problems (the clients will need to reconnec, but even their players objects will be kept in the same state with no data loss). To keep the system working you have to assure that the object state values are synced over the networking, using the NetworkValues or using INetworkBehaviourSerializer callbacks. If you need aditional syncing you can request a custom packet in the NetworkBehaviour.OnSpawned callback as well, using the parameter isRetroactive to check if it's a late joining syncing or not. We heavily recommend, that after every single big system modification / addition the developers make the following checks: The Hot-Reloading feature still works with your system Mid/Late-Joiners have no issues syncing your game state This two checks assures that you won't have any state-sycning problems over the network, and every single client/player will be able to sync the game state with no issues at all. The hot-reloading is not mandatory but it can speeds the network testing, as you can modify code and NetworkValues via inspector without losing the server current state.","title":"Reconnection and Hot-Reload"},{"location":"reconnection_and_hot_reload/#reconnection-and-hot-reload","text":"NetBuff supports mid/late-game connections with no problems: Every single NetworkIdentity from every single scene will be synced, within it's values and it's additional serialized data. Even on editor, you can edit the code, recompile the project and the server will keep it's state with no problems (the clients will need to reconnec, but even their players objects will be kept in the same state with no data loss). To keep the system working you have to assure that the object state values are synced over the networking, using the NetworkValues or using INetworkBehaviourSerializer callbacks. If you need aditional syncing you can request a custom packet in the NetworkBehaviour.OnSpawned callback as well, using the parameter isRetroactive to check if it's a late joining syncing or not. We heavily recommend, that after every single big system modification / addition the developers make the following checks: The Hot-Reloading feature still works with your system Mid/Late-Joiners have no issues syncing your game state This two checks assures that you won't have any state-sycning problems over the network, and every single client/player will be able to sync the game state with no issues at all. The hot-reloading is not mandatory but it can speeds the network testing, as you can modify code and NetworkValues via inspector without losing the server current state.","title":"Reconnection And Hot Reload"},{"location":"scene_management/","text":"Managing Scenes NetBuff supports loading/unloading scenes in runtime, allowing the system to provide level loading/unloading flow control and other scene-based control flow. Every single NetworkIdentity object has the field NetworkIdentity.SceneId that represents in which network loaded scene the object is: public int SceneId; Scene Id Rules The scene where your NetworkManager is located is considered the main scene, as the networking process will always start from there. The main scene will always have the id of 0. Everyother scene will have the id linked to its position if the NetworkManager.LoadedScenes list You start the network You load the scene \"Test1.unity\". It'll have the id 1 You load the scene \"Test2.unity\". It'll have the id 2 You unload the scene \"Test1.unity\" Now the scene Test2 becomes the scene 1, cause it's linked to loaded scenes list You can always use the scene id -1 to spawn or move objects around. This id represents the NetworkManager.LastLoadedScene (the scene in the last position of the loaded scenes list). If no additional scene is loaded it will point to the main scene. Loading and Unloading Scenes Only the server can load and unload scenes, but anyone can check if a scene is loaded and which scenes are loaded right now. The NetworkIdentity.SceneId will be synced between every network end and every other scene-related method/property will work in any end as well. You can load / unload scenes using the NetworkManager.LoadScene and NetworkManager.UnloadScene methods: public class SceneLoadingController : NetworkBehaviour { public string scene1 = \"Scene1\"; public void Update() { if (IsServer) { if (Input.GetKeyDown(KeyCode.Alpha1)) { //Checks if the scene is already loaded if (NetworkManager.Instance.IsSceneLoaded(scene1)) //Unloads the scene NetworkManager.Instance.UnloadScene(scene1); else //Loads the scene NetworkManager.Instance.LoadScene(scene1); } } } } When you unload a scene all the NetworkIdentity objects in it will be despawned with no issues. If a late-joiner enters the game, every single object in every single scene will be synced with no problems as well. Moving Objects Between Scenes If you have the ownership over a NetworkIdentity object, you can move it between scenes easily, using the NetworkIdentity.MoveToScene method: public void Update() { if(!HasAuthority) return; if (Input.GetKeyDown(KeyCode.M)) { var id = SceneId + 1; if (id >= LoadedSceneCount) id = 0; //Moves the object to the next loaded scene MoveToScene(id); } } Main Scene The main scene is the scene where your NetworkManager is. It can't be unloaded and is the scene where player prefabs spawns by default. We heavily recommend that you leave the players and anything scene-persistent on the main scene, like singletons, controllers, etc...","title":"Managing Scenes"},{"location":"scene_management/#managing-scenes","text":"NetBuff supports loading/unloading scenes in runtime, allowing the system to provide level loading/unloading flow control and other scene-based control flow. Every single NetworkIdentity object has the field NetworkIdentity.SceneId that represents in which network loaded scene the object is: public int SceneId;","title":"Managing Scenes"},{"location":"scene_management/#scene-id-rules","text":"The scene where your NetworkManager is located is considered the main scene, as the networking process will always start from there. The main scene will always have the id of 0. Everyother scene will have the id linked to its position if the NetworkManager.LoadedScenes list You start the network You load the scene \"Test1.unity\". It'll have the id 1 You load the scene \"Test2.unity\". It'll have the id 2 You unload the scene \"Test1.unity\" Now the scene Test2 becomes the scene 1, cause it's linked to loaded scenes list You can always use the scene id -1 to spawn or move objects around. This id represents the NetworkManager.LastLoadedScene (the scene in the last position of the loaded scenes list). If no additional scene is loaded it will point to the main scene.","title":"Scene Id Rules"},{"location":"scene_management/#loading-and-unloading-scenes","text":"Only the server can load and unload scenes, but anyone can check if a scene is loaded and which scenes are loaded right now. The NetworkIdentity.SceneId will be synced between every network end and every other scene-related method/property will work in any end as well. You can load / unload scenes using the NetworkManager.LoadScene and NetworkManager.UnloadScene methods: public class SceneLoadingController : NetworkBehaviour { public string scene1 = \"Scene1\"; public void Update() { if (IsServer) { if (Input.GetKeyDown(KeyCode.Alpha1)) { //Checks if the scene is already loaded if (NetworkManager.Instance.IsSceneLoaded(scene1)) //Unloads the scene NetworkManager.Instance.UnloadScene(scene1); else //Loads the scene NetworkManager.Instance.LoadScene(scene1); } } } } When you unload a scene all the NetworkIdentity objects in it will be despawned with no issues. If a late-joiner enters the game, every single object in every single scene will be synced with no problems as well.","title":"Loading and Unloading Scenes"},{"location":"scene_management/#moving-objects-between-scenes","text":"If you have the ownership over a NetworkIdentity object, you can move it between scenes easily, using the NetworkIdentity.MoveToScene method: public void Update() { if(!HasAuthority) return; if (Input.GetKeyDown(KeyCode.M)) { var id = SceneId + 1; if (id >= LoadedSceneCount) id = 0; //Moves the object to the next loaded scene MoveToScene(id); } }","title":"Moving Objects Between Scenes"},{"location":"scene_management/#main-scene","text":"The main scene is the scene where your NetworkManager is. It can't be unloaded and is the scene where player prefabs spawns by default. We heavily recommend that you leave the players and anything scene-persistent on the main scene, like singletons, controllers, etc...","title":"Main Scene"}]}