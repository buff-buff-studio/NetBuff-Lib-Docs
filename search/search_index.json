{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p> </p> </p>"},{"location":"#netbuff-unity-networking-system","title":"NetBuff - Unity Networking System","text":"<p>NetBuff is a networking system based on the Unity game engine. Initially created for a college project, the system has been improved to the point of deserving to be polished and released / made available separately.</p> <p>The NetBuff comes as a lighter and simpler alternative to other existing solutions such as Unity's own NGO (Netcode For GameObjects) and third-party solutions (Mirror, etc...)</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Advanced Editor tools</li> <li>Hot-Reload (Server maintains its state after a recompile)</li> <li>Server password protection</li> <li>Server discovery system</li> <li>Reliable packet delivery</li> <li>Lightweight and optimized</li> <li>Simple to implement</li> <li>Support for multiple scenes</li> </ul>"},{"location":"#installation-guide","title":"Installation Guide","text":"<ol> <li>Go to the Unity Package Manager (Window -&gt; Package Manager).</li> <li>Click the \"+\" button in the top-left corner of the window.</li> <li>Select \"Add package from git URL...\".</li> <li>Paste the link below and click \"Add\".</li> </ol> <pre><code>https://github.com/buff-buff-studio/NetBuff-Lib.git#package\n</code></pre>"},{"location":"#supported-transport-methods","title":"Supported Transport Methods","text":"<ul> <li>UDP</li> <li>Local (Split Screen)</li> <li>Custom Transports</li> </ul>"},{"location":"#credits","title":"Credits","text":"<ul> <li>Scripts by @arnilsenarthur</li> <li>Package management by @SergioMacellani</li> <li>LiteNetLib by RevenantX</li> <li>Serialized Dictionary by ayellowpaper</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#animatorsyncpacket","title":"AnimatorSyncPacket","text":"Class NetBuff.Components.AnimatorSyncPacket"},{"location":"api_reference/#implements","title":"Implements","text":"NetBuff.Interface.IOwnedPacket"},{"location":"api_reference/#properties","title":"Properties","text":"Property Accessors Description public NetworkId IdOverrides Get Set public Changes Change Get Set public LayerInfo[] Layers Get Set public float Speed Get Set public byte ChangedParameters Get Set public byte[] ParameterData Get Set"},{"location":"api_reference/#methods","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#animatortriggerpacket","title":"AnimatorTriggerPacket","text":"Class NetBuff.Components.AnimatorTriggerPacket"},{"location":"api_reference/#implements_1","title":"Implements","text":"NetBuff.Interface.IOwnedPacket"},{"location":"api_reference/#properties_1","title":"Properties","text":"Property Accessors Description public NetworkId IdOverrides Get Set public int TriggerHash Get Set"},{"location":"api_reference/#methods_1","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#boolnetworkvalue","title":"BoolNetworkValue","text":"Class NetBuff.Misc.BoolNetworkValue"},{"location":"api_reference/#implements_2","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_2","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#bytenetworkvalue","title":"ByteNetworkValue","text":"Class NetBuff.Misc.ByteNetworkValue"},{"location":"api_reference/#implements_3","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_3","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#changes","title":"Changes","text":"Enum NetBuff.Components.AnimatorSyncPacket.Changes"},{"location":"api_reference/#enum-values","title":"Enum Values","text":"Value Description None Layers Parameters Speed"},{"location":"api_reference/#clientidpacket","title":"ClientIdPacket","text":"Class NetBuff.Packets.ClientIdPacket"},{"location":"api_reference/#implements_4","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_2","title":"Properties","text":"Property Accessors Description public int ClientId Get Set"},{"location":"api_reference/#methods_4","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#clientonlyattribute","title":"ClientOnlyAttribute","text":"Class NetBuff.Misc.ClientOnlyAttribute"},{"location":"api_reference/#colornetworkvalue","title":"ColorNetworkValue","text":"Class NetBuff.Misc.ColorNetworkValue"},{"location":"api_reference/#implements_5","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_5","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#doublenetworkvalue","title":"DoubleNetworkValue","text":"Class NetBuff.Misc.DoubleNetworkValue"},{"location":"api_reference/#implements_6","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_6","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#endtype","title":"EndType","text":"Enum NetBuff.NetworkTransport.EndType"},{"location":"api_reference/#enum-values_1","title":"Enum Values","text":"Value Description None Server Host Client"},{"location":"api_reference/#floatnetworkvalue","title":"FloatNetworkValue","text":"Class NetBuff.Misc.FloatNetworkValue"},{"location":"api_reference/#implements_7","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_7","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#gameinfo","title":"GameInfo","text":"Class NetBuff.Discover.ServerDiscover.GameInfo"},{"location":"api_reference/#properties_3","title":"Properties","text":"Property Accessors Description public string Name Get Set public int Players Get Set public int MaxPlayers Get Set public Platform Platform Get Set public bool HasPassword Get Set public string Method Get Set"},{"location":"api_reference/#methods_8","title":"Methods","text":"Method Parameters Description public string ToString public bool Join"},{"location":"api_reference/#iclientconnectioninfo","title":"IClientConnectionInfo","text":"Interface NetBuff.Interface.IClientConnectionInfo"},{"location":"api_reference/#implements_8","title":"Implements","text":"NetBuff.Interface.IConnectionInfo"},{"location":"api_reference/#properties_4","title":"Properties","text":"Property Accessors Description public int Id Get public int LatencyOverrides Get public long PacketSentOverrides Get public long PacketReceivedOverrides Get public long PacketLossOverrides Get public long PacketLossPercentageOverrides Get"},{"location":"api_reference/#iconnectioninfo","title":"IConnectionInfo","text":"Interface NetBuff.Interface.IConnectionInfo"},{"location":"api_reference/#properties_5","title":"Properties","text":"Property Accessors Description public int Latency Get public long PacketSent Get public long PacketReceived Get public long PacketLoss Get public long PacketLossPercentage Get"},{"location":"api_reference/#inetworkbehaviourserializer","title":"INetworkBehaviourSerializer","text":"Interface NetBuff.Interface.INetworkBehaviourSerializer"},{"location":"api_reference/#methods_9","title":"Methods","text":"Method Parameters Description public void OnSerialize BinaryWriter writerbool forceSendAll public void OnDeserialize BinaryReader reader"},{"location":"api_reference/#intnetworkvalue","title":"IntNetworkValue","text":"Class NetBuff.Misc.IntNetworkValue"},{"location":"api_reference/#implements_9","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_10","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#iownedpacket","title":"IOwnedPacket","text":"Interface NetBuff.Interface.IOwnedPacket"},{"location":"api_reference/#implements_10","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_6","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set"},{"location":"api_reference/#methods_11","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#ipacket","title":"IPacket","text":"Interface NetBuff.Interface.IPacket"},{"location":"api_reference/#methods_12","title":"Methods","text":"Method Parameters Description public void Serialize BinaryWriter writer public void Deserialize BinaryReader reader"},{"location":"api_reference/#layerinfo","title":"LayerInfo","text":"Class NetBuff.Components.AnimatorSyncPacket.LayerInfo"},{"location":"api_reference/#properties_7","title":"Properties","text":"Property Accessors Description public byte LayerIndex Get Set public int StateHash Get Set public float NormalizedTime Get Set public float LayerWeight Get Set"},{"location":"api_reference/#localclientconnectioninfo","title":"LocalClientConnectionInfo","text":"Class NetBuff.Local.LocalNetworkTransport.LocalClientConnectionInfo"},{"location":"api_reference/#implements_11","title":"Implements","text":"NetBuff.Interface.IClientConnectionInfo"},{"location":"api_reference/#properties_8","title":"Properties","text":"Property Accessors Description public int LatencyOverrides Get public long PacketSentOverrides Get public long PacketReceivedOverrides Get public long PacketLossOverrides Get public int IdOverrides Get"},{"location":"api_reference/#localnetworktransport","title":"LocalNetworkTransport","text":"Class NetBuff.Local.LocalNetworkTransport"},{"location":"api_reference/#implements_12","title":"Implements","text":"NetBuff.NetworkTransport"},{"location":"api_reference/#properties_9","title":"Properties","text":"Property Accessors Description public int ClientCount Get Set"},{"location":"api_reference/#methods_13","title":"Methods","text":"Method Parameters Description public ServerDiscover GetServerDiscovererOverrides public void StartHostOverrides int magicNumber public void StartServerOverrides public void StartClientOverrides int magicNumber public void CloseOverrides public IClientConnectionInfo GetClientInfoOverrides int id public int GetClientCountOverrides public IEnumerable&lt;IClientConnectionInfo&gt; GetClientsOverrides public void ClientDisconnectOverrides string reason public void ServerDisconnectOverrides int idstring reason public void SendClientPacketOverrides IPacket packetbool reliable = false public void SendServerPacketOverrides IPacket packetint target = -1bool reliable = false"},{"location":"api_reference/#longnetworkvalue","title":"LongNetworkValue","text":"Class NetBuff.Misc.LongNetworkValue"},{"location":"api_reference/#implements_13","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_14","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#modifiertype","title":"ModifierType","text":"Enum NetBuff.Misc.NetworkValue.ModifierType"},{"location":"api_reference/#enum-values_2","title":"Enum Values","text":"Value Description OwnerOnly Server Everybody"},{"location":"api_reference/#networkanimator","title":"NetworkAnimator","text":"Class NetBuff.Components.NetworkAnimator"},{"location":"api_reference/#implements_14","title":"Implements","text":"NetBuff.Components.NetworkBehaviour NetBuff.Interface.INetworkBehaviourSerializer"},{"location":"api_reference/#properties_10","title":"Properties","text":"Property Accessors Description public int TickRate Get Set public Animator Animator Get"},{"location":"api_reference/#methods_15","title":"Methods","text":"Method Parameters Description public void SetTrigger int triggerHash public void SetTrigger string triggerName public float GetFloat string name public void SetFloat string namefloat value public float GetFloat int nameHash public void SetFloat int nameHashfloat value public bool GetBool string name public void SetBool string namebool value public bool GetBool int nameHash public void SetBool int nameHashbool value public int GetInteger string name public void SetInteger string nameint value public int GetInteger int nameHash public void SetInteger int nameHashint value public void OnSpawnedOverrides bool isRetroactive public void OnServerReceivePacketOverrides IOwnedPacket packetint clientId public void OnClientReceivePacketOverrides IOwnedPacket packet public void OnSerializeOverrides BinaryWriter writerbool forceSendAll public void OnDeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkbehaviour","title":"NetworkBehaviour","text":"Class NetBuff.Components.NetworkBehaviour"},{"location":"api_reference/#properties_11","title":"Properties","text":"Property Accessors Description public byte BehaviourId Get public bool IsDirty Get public ReadOnlySpan&lt;NetworkValue&gt; Values Get public NetworkIdentity Identity Get public NetworkId Id Get public int OwnerId Get public NetworkId PrefabId Get public bool HasAuthority Get public bool IsOwnedByClient Get public int SceneId Get public bool IsServer Get public int LoadedSceneCount Get public string SourceScene Get public string LastLoadedScene Get"},{"location":"api_reference/#methods_16","title":"Methods","text":"Method Parameters Description Serverpublic void OnServerReceivePacket IOwnedPacket packetint clientId Clientpublic void OnClientReceivePacket IOwnedPacket packet public void OnSpawned bool isRetroactive public void OnSceneChanged int fromSceneint toScene Serverpublic void OnClientConnected int clientId Serverpublic void OnClientDisconnected int clientId public void OnDespawned public void OnActiveChanged bool active public void OnOwnershipChanged int oldOwnerint newOwner public void OnSceneLoaded int sceneId public void OnSceneUnloaded int sceneId public void OnAnyObjectSpawned NetworkIdentity identitybool isRetroactive public void WithValues NetworkValue[] values public void MarkValueDirty NetworkValue value public void MarkValueDirty byte index public void MarkSerializerDirty public void UpdateDirtyValues Serverpublic void SendNetworkValuesToClient int clientId Serverpublic NetworkValuesPacket GetPreExistingValuesPacket public void ApplyDirtyValues byte[] payload Serverpublic void ServerBroadcastPacket IPacket packetbool reliable = false Serverpublic void ServerBroadcastPacketExceptFor IPacket packetint exceptbool reliable = false Serverpublic void ServerSendPacket IPacket packetint clientIdbool reliable = false Clientpublic void ClientSendPacket IPacket packetbool reliable = false public void SendPacket IPacket packetbool reliable = false public PacketListener GetPacketListener Requires Authoritypublic void Despawn Requires Authoritypublic void SetActive bool active Requires Authoritypublic void SetOwner int clientId Serverpublic void ForceSetOwner int clientId public static NetworkIdentity GetNetworkObject NetworkId objectId public static IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjects public static int GetNetworkObjectCount public static IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjectsOwnedBy int clientId Clientpublic int GetLocalClientIndex int clientId Clientpublic int GetLocalClientCount Clientpublic ReadOnlySpan GetLocalClientIds public GameObject GetPrefabById NetworkId prefab public NetworkId GetIdForPrefab GameObject prefab public bool IsPrefabValid NetworkId prefab Requires Authoritypublic void MoveToScene int sceneId Requires Authoritypublic void MoveToScene string sceneName public IEnumerable GetLoadedScenes public int GetSceneId string sceneName public string GetSceneName int sceneId public static NetworkId Spawn GameObject prefab public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationbool active public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationint owner public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotation public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationVector3 scalebool activeint owner = -1int scene = -1 public static NetworkId Spawn NetworkId prefabIdVector3 positionQuaternion rotationVector3 scalebool activeint owner = -1int scene = -1"},{"location":"api_reference/#networkid","title":"NetworkId","text":"Class NetBuff.Misc.NetworkId"},{"location":"api_reference/#properties_12","title":"Properties","text":"Property Accessors Description public static NetworkId Empty Get public bool IsEmpty Get public int High Get public int Low Get"},{"location":"api_reference/#methods_17","title":"Methods","text":"Method Parameters Description public static NetworkId New public static NetworkId Read BinaryReader reader public int CompareTo object obj public bool Equals object obj public int GetHashCode public NetworkId Serialize BinaryWriter writer public NetworkId Deserialize BinaryReader reader public string ToString public static bool TryParse string inputobject result"},{"location":"api_reference/#networkidentity","title":"NetworkIdentity","text":"Class NetBuff.Components.NetworkIdentity"},{"location":"api_reference/#properties_13","title":"Properties","text":"Property Accessors Description public NetworkId Id Get public int OwnerId Get public NetworkId PrefabId Get public bool HasAuthority Get public bool IsOwnedByClient Get public int SceneId Get public bool IsServer Get public int LoadedSceneCount Get public string SourceScene Get public string LastLoadedScene Get public NetworkBehaviour[] Behaviours Get"},{"location":"api_reference/#methods_18","title":"Methods","text":"Method Parameters Description Serverpublic void ServerBroadcastPacket IPacket packetbool reliable = false Serverpublic void ServerBroadcastPacketExceptFor IPacket packetint exceptbool reliable = false Serverpublic void ServerSendPacket IPacket packetint clientIdbool reliable = false Clientpublic void ClientSendPacket IPacket packetbool reliable = false public void SendPacket IPacket packetbool reliable = false public PacketListener GetPacketListener Requires Authoritypublic void Despawn Requires Authoritypublic void SetActive bool active Requires Authoritypublic void SetOwner int clientId Serverpublic void ForceSetOwner int clientId public static NetworkIdentity GetNetworkObject NetworkId objectId public static IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjects public static int GetNetworkObjectCount public static IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjectsOwnedBy int clientId Clientpublic int GetLocalClientIndex int clientId Clientpublic int GetLocalClientCount Clientpublic ReadOnlySpan GetLocalClientIds public GameObject GetPrefabById NetworkId prefab public NetworkId GetIdForPrefab GameObject prefab public bool IsPrefabValid NetworkId prefab Requires Authoritypublic void MoveToScene int sceneId Requires Authoritypublic void MoveToScene string sceneName public IEnumerable GetLoadedScenes public int GetSceneId string sceneName public string GetSceneName int sceneId public static NetworkId Spawn GameObject prefab public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationbool active public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationint owner public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotation public static NetworkId Spawn GameObject prefabVector3 positionQuaternion rotationVector3 scalebool activeint owner = -1int scene = -1 public static NetworkId Spawn NetworkId prefabIdVector3 positionQuaternion rotationVector3 scalebool activeint owner = -1int scene = -1"},{"location":"api_reference/#networkidnetworkvalue","title":"NetworkIdNetworkValue","text":"Class NetBuff.Misc.NetworkIdNetworkValue"},{"location":"api_reference/#implements_15","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_19","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkloadscenepacket","title":"NetworkLoadScenePacket","text":"Class NetBuff.Packets.NetworkLoadScenePacket"},{"location":"api_reference/#implements_16","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_14","title":"Properties","text":"Property Accessors Description public string SceneName Get Set"},{"location":"api_reference/#methods_20","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkmanager","title":"NetworkManager","text":"Class NetBuff.NetworkManager"},{"location":"api_reference/#properties_15","title":"Properties","text":"Property Accessors Description public static NetworkManager Instance Get Set public int VersionMagicNumber Get Set public int DefaultTickRate Get Set public bool SpawnsPlayer Get Set public NetworkTransport Transport Get Set public NetworkPrefabRegistry PrefabRegistry Get Set public GameObject PlayerPrefab Get Set public bool IsClientRunning Get Set public bool IsServerRunning Get Set public IList&lt;NetworkBehaviour&gt; DirtyBehaviours Get public NetworkTransport.EndType EndType Get Clientpublic IConnectionInfo ClientConnectionInfo Get Clientpublic ReadOnlySpan LocalClientIds Get public string SourceScene Get public IEnumerable LoadedScenes Get public int LoadedSceneCount Get public string LastLoadedScene Get"},{"location":"api_reference/#methods_21","title":"Methods","text":"Method Parameters Description public void StartClient public void StartServer public void StartHost public void Close public PacketListener GetPacketListener public PacketListener GetPacketListener Type type public NetworkIdentity GetNetworkObject NetworkId id public IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjects public int GetNetworkObjectCount public IEnumerable&lt;NetworkIdentity&gt; GetNetworkObjectsOwnedBy int owner Serverpublic void SpawnNetworkObjectForClients NetworkId prefabIdVector3 positionQuaternion rotationVector3 scaleint owner = -1int scene = -1 Serverpublic void SetNetworkObjectOwnerForClients NetworkId idint owner Serverpublic void SetNetworkObjectActiveForClients NetworkId idbool active Serverpublic void DespawnNetworkObjectForClients NetworkId id protected void OnServerStart protected void OnServerStop protected void OnNetworkObjectSpawned NetworkIdentity identitybool retroactive protected void OnNetworkObjectDespawned NetworkIdentity identity Serverprotected void OnClientConnected int clientId Serverprotected void OnClientDisconnected int clientIdstring reason Serverprotected void OnSpawnPlayer int clientId Clientprotected void OnConnect Clientprotected void OnDisconnect string reason Serverprotected void OnServerReceivePacket int clientIdIPacket packet protected void OnClientReceivePacket IPacket packet protected void OnClearEnvironment protected GameObject OnSpawnObject NetworkId idGameObject prefabVector3 positionQuaternion rotationVector3 scalebool activeint ownerint sceneId protected void OnDespawnObject GameObject o Clientpublic void SendClientPacket IPacket packetbool reliable = false Serverpublic void SendServerPacket IPacket packetint target = -1bool reliable = false Serverpublic void BroadcastServerPacket IPacket packetbool reliable = false Serverpublic void BroadcastServerPacketExceptFor IPacket packetint exceptbool reliable = false public int GetSceneId string sceneName public string GetSceneName int sceneId Serverpublic void LoadScene string sceneName Serverpublic void UnloadScene string sceneName public bool IsSceneLoaded string sceneName public void MoveObjectToScene NetworkId idint sceneId"},{"location":"api_reference/#networkmanagergui","title":"NetworkManagerGUI","text":"Class NetBuff.NetworkManagerGUI"},{"location":"api_reference/#networkobjectactivepacket","title":"NetworkObjectActivePacket","text":"Class NetBuff.Packets.NetworkObjectActivePacket"},{"location":"api_reference/#implements_17","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_16","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public bool IsActive Get Set"},{"location":"api_reference/#methods_22","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkobjectdespawnpacket","title":"NetworkObjectDespawnPacket","text":"Class NetBuff.Packets.NetworkObjectDespawnPacket"},{"location":"api_reference/#implements_18","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_17","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set"},{"location":"api_reference/#methods_23","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkobjectmovescenepacket","title":"NetworkObjectMoveScenePacket","text":"Class NetBuff.Packets.NetworkObjectMoveScenePacket"},{"location":"api_reference/#implements_19","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_18","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public int SceneId Get Set"},{"location":"api_reference/#methods_24","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkobjectownerpacket","title":"NetworkObjectOwnerPacket","text":"Class NetBuff.Packets.NetworkObjectOwnerPacket"},{"location":"api_reference/#implements_20","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_19","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public int OwnerId Get Set"},{"location":"api_reference/#methods_25","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkobjectspawnpacket","title":"NetworkObjectSpawnPacket","text":"Class NetBuff.Packets.NetworkObjectSpawnPacket"},{"location":"api_reference/#implements_21","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_20","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public NetworkId PrefabId Get Set public int OwnerId Get Set public Vector3 Position Get Set public Quaternion Rotation Get Set public Vector3 Scale Get Set public bool IsActive Get Set public bool IsRetroactive Get Set public int SceneId Get Set"},{"location":"api_reference/#methods_26","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkpreexistinginfopacket","title":"NetworkPreExistingInfoPacket","text":"Class NetBuff.Packets.NetworkPreExistingInfoPacket"},{"location":"api_reference/#implements_22","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_21","title":"Properties","text":"Property Accessors Description public PreExistingState[] PreExistingObjects Get Set public NetworkId[] RemovedObjects Get Set public string[] SceneNames Get Set public NetworkObjectSpawnPacket[] SpawnedObjects Get Set public NetworkValuesPacket[] NetworkValues Get Set"},{"location":"api_reference/#methods_27","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkpreexistingresponsepacket","title":"NetworkPreExistingResponsePacket","text":"Class NetBuff.Packets.NetworkPreExistingResponsePacket"},{"location":"api_reference/#implements_23","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#methods_28","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkprefabregistry","title":"NetworkPrefabRegistry","text":"Class NetBuff.NetworkPrefabRegistry"},{"location":"api_reference/#properties_22","title":"Properties","text":"Property Accessors Description public SerializedDictionary&lt;NetworkId,GameObject&gt; Prefabs Get"},{"location":"api_reference/#methods_29","title":"Methods","text":"Method Parameters Description public bool IsPrefabValid NetworkId id public bool IsPrefabValid GameObject prefab public NetworkId GetPrefabId GameObject prefab public GameObject GetPrefab NetworkId id public IEnumerable GetAllPrefabs"},{"location":"api_reference/#networkrigidbodytransform","title":"NetworkRigidbodyTransform","text":"Class NetBuff.Components.NetworkRigidbodyTransform"},{"location":"api_reference/#implements_24","title":"Implements","text":"NetBuff.Components.NetworkTransform"},{"location":"api_reference/#properties_23","title":"Properties","text":"Property Accessors Description public Rigidbody Rigidbody Get public bool SyncVelocity Get Set public float VelocityThreshold Get Set public bool SyncAngularVelocity Get Set public float AngularVelocityThreshold Get Set public bool SyncIsKinematic Get Set"},{"location":"api_reference/#methods_30","title":"Methods","text":"Method Parameters Description protected bool ShouldResendOverrides TransformPacket packet protected void ApplyTransformPacketOverrides TransformPacket packet"},{"location":"api_reference/#networktransform","title":"NetworkTransform","text":"Class NetBuff.Components.NetworkTransform"},{"location":"api_reference/#implements_25","title":"Implements","text":"NetBuff.Components.NetworkBehaviour"},{"location":"api_reference/#properties_24","title":"Properties","text":"Property Accessors Description public int TickRate Get Set public float PositionThreshold Get Set public float RotationThreshold Get Set public float ScaleThreshold Get Set public SyncMode SyncModeMask Get"},{"location":"api_reference/#methods_31","title":"Methods","text":"Method Parameters Description public void OnOwnershipChangedOverrides int oldOwnerint newOwner public void OnSpawnedOverrides bool isRetroactive public void OnServerReceivePacketOverrides IOwnedPacket packetint clientId public void OnClientReceivePacketOverrides IOwnedPacket packet protected bool ShouldResend TransformPacket packet protected void ApplyTransformPacket TransformPacket packet"},{"location":"api_reference/#networktransport","title":"NetworkTransport","text":"Class NetBuff.NetworkTransport"},{"location":"api_reference/#properties_25","title":"Properties","text":"Property Accessors Description public EndType Type Get Set public IConnectionInfo ClientConnectionInfo Get Set public string Name Get Set public ActionIPacket\\&gt; OnServerPacketReceived Get Set public Action&lt;IPacket&gt; OnClientPacketReceived Get Set public Action OnClientConnected Get Set public Action OnClientDisconnected Get Set public Action OnConnect Get Set public Action OnDisconnect Get Set public Action OnServerStart Get Set public Action OnServerStop Get Set"},{"location":"api_reference/#methods_32","title":"Methods","text":"Method Parameters Description public ServerDiscover GetServerDiscoverer public void StartHost int magicNumber public void StartServer public void StartClient int magicNumber public void Close Serverpublic IClientConnectionInfo GetClientInfo int id Serverpublic int GetClientCount Serverpublic IEnumerable&lt;IClientConnectionInfo&gt; GetClients Clientpublic void ClientDisconnect string reason Serverpublic void ServerDisconnect int idstring reason Clientpublic void SendClientPacket IPacket packetbool reliable = false Serverpublic void SendServerPacket IPacket packetint target = -1bool reliable = false Serverpublic void BroadcastServerPacket IPacket packetbool reliable = false"},{"location":"api_reference/#networkunloadscenepacket","title":"NetworkUnloadScenePacket","text":"Class NetBuff.Packets.NetworkUnloadScenePacket"},{"location":"api_reference/#implements_26","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_26","title":"Properties","text":"Property Accessors Description public string SceneName Get Set"},{"location":"api_reference/#methods_33","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#networkvalue","title":"NetworkValue","text":"Class NetBuff.Misc.NetworkValue"},{"location":"api_reference/#properties_27","title":"Properties","text":"Property Accessors Description public NetworkBehaviour AttachedTo Get Set"},{"location":"api_reference/#methods_34","title":"Methods","text":"Method Parameters Description public void Serialize BinaryWriter writer public void Deserialize BinaryReader reader"},{"location":"api_reference/#networkvaluet","title":"NetworkValue&lt;T&gt;","text":"Class NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#implements_27","title":"Implements","text":"NetBuff.Misc.NetworkValue"},{"location":"api_reference/#properties_28","title":"Properties","text":"Property Accessors Description public T Value Get Set"},{"location":"api_reference/#methods_35","title":"Methods","text":"Method Parameters Description public bool CheckPermission protected void SetValueCalling T newValue public string ToString"},{"location":"api_reference/#networkvaluespacket","title":"NetworkValuesPacket","text":"Class NetBuff.Packets.NetworkValuesPacket"},{"location":"api_reference/#implements_28","title":"Implements","text":"NetBuff.Interface.IPacket"},{"location":"api_reference/#properties_29","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public byte BehaviourId Get Set public byte[] Payload Get Set"},{"location":"api_reference/#methods_36","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#packetlistener","title":"PacketListener","text":"Class NetBuff.Misc.PacketListener"},{"location":"api_reference/#methods_37","title":"Methods","text":"Method Parameters Description public void CallOnServerReceive IPacket packetint client public void CallOnClientReceive IPacket packet"},{"location":"api_reference/#packetlistenert","title":"PacketListener&lt;T&gt;","text":"Class NetBuff.Misc.PacketListener&lt;T&gt;"},{"location":"api_reference/#implements_29","title":"Implements","text":"NetBuff.Misc.PacketListener"},{"location":"api_reference/#methods_38","title":"Methods","text":"Method Parameters Description public void CallOnServerReceiveOverrides IPacket packetint client public void CallOnClientReceiveOverrides IPacket packet"},{"location":"api_reference/#packetregistry","title":"PacketRegistry","text":"Class NetBuff.PacketRegistry"},{"location":"api_reference/#methods_39","title":"Methods","text":"Method Parameters Description public static void RegisterPacket public static void RegisterPacket Type type public static void Clear public static int GetId public static int GetId IPacket packet public static IPacket CreatePacket int id"},{"location":"api_reference/#platform","title":"Platform","text":"Enum NetBuff.Misc.Platform"},{"location":"api_reference/#enum-values_3","title":"Enum Values","text":"Value Description Desktop Windows Linux MacOS Mobile Android IOS Unknown"},{"location":"api_reference/#platformextensions","title":"PlatformExtensions","text":"Class NetBuff.Misc.PlatformExtensions"},{"location":"api_reference/#methods_40","title":"Methods","text":"Method Parameters Description public static Platform GetPlatform"},{"location":"api_reference/#preexistingstate","title":"PreExistingState","text":"Class NetBuff.Packets.NetworkPreExistingInfoPacket.PreExistingState"},{"location":"api_reference/#properties_30","title":"Properties","text":"Property Accessors Description public NetworkId Id Get Set public NetworkId PrefabId Get Set public int OwnerId Get Set public Vector3 Position Get Set public Quaternion Rotation Get Set public Vector3 Scale Get Set public bool IsActive Get Set public int SceneId Get Set"},{"location":"api_reference/#quaternionnetworkvalue","title":"QuaternionNetworkValue","text":"Class NetBuff.Misc.QuaternionNetworkValue"},{"location":"api_reference/#implements_30","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_41","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#requiresauthorityattribute","title":"RequiresAuthorityAttribute","text":"Class NetBuff.Misc.RequiresAuthorityAttribute"},{"location":"api_reference/#serverdiscover","title":"ServerDiscover","text":"Class NetBuff.Discover.ServerDiscover"},{"location":"api_reference/#methods_42","title":"Methods","text":"Method Parameters Description public void Search Action&lt;GameInfo&gt; onFindServerAction onFinish"},{"location":"api_reference/#serverdiscovert","title":"ServerDiscover&lt;T&gt;","text":"Class NetBuff.Discover.ServerDiscover&lt;T&gt;"},{"location":"api_reference/#implements_31","title":"Implements","text":"NetBuff.Discover.ServerDiscover"},{"location":"api_reference/#methods_43","title":"Methods","text":"Method Parameters Description public void SearchOverrides Action onFindServerAction onFinish public void Cancel public void Search Action&lt;GameInfo&gt; onFindServerAction onFinish"},{"location":"api_reference/#serveronlyattribute","title":"ServerOnlyAttribute","text":"Class NetBuff.Misc.ServerOnlyAttribute"},{"location":"api_reference/#shortnetworkvalue","title":"ShortNetworkValue","text":"Class NetBuff.Misc.ShortNetworkValue"},{"location":"api_reference/#implements_32","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_44","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#stringnetworkvalue","title":"StringNetworkValue","text":"Class NetBuff.Misc.StringNetworkValue"},{"location":"api_reference/#implements_33","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_45","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#syncmode","title":"SyncMode","text":"Enum NetBuff.Components.NetworkTransform.SyncMode"},{"location":"api_reference/#enum-values_4","title":"Enum Values","text":"Value Description None PositionX PositionY PositionZ RotationX RotationY RotationZ ScaleX ScaleY ScaleZ"},{"location":"api_reference/#transformpacket","title":"TransformPacket","text":"Class NetBuff.Components.TransformPacket"},{"location":"api_reference/#implements_34","title":"Implements","text":"NetBuff.Interface.IOwnedPacket"},{"location":"api_reference/#properties_31","title":"Properties","text":"Property Accessors Description public NetworkId IdOverrides Get Set public float[] Components Get Set public short Flag Get Set"},{"location":"api_reference/#methods_46","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#udpgameinfo","title":"UDPGameInfo","text":"Class NetBuff.Discover.UDPServerDiscoverer.UDPGameInfo"},{"location":"api_reference/#implements_35","title":"Implements","text":"NetBuff.Discover.ServerDiscover.GameInfo"},{"location":"api_reference/#properties_32","title":"Properties","text":"Property Accessors Description public IPAddress Address Get Set"},{"location":"api_reference/#methods_47","title":"Methods","text":"Method Parameters Description public string ToStringOverrides public bool JoinOverrides"},{"location":"api_reference/#udpnetworktransport","title":"UDPNetworkTransport","text":"Class NetBuff.UDP.UDPNetworkTransport"},{"location":"api_reference/#implements_36","title":"Implements","text":"NetBuff.NetworkTransport"},{"location":"api_reference/#properties_33","title":"Properties","text":"Property Accessors Description public string Address Get Set public int Port Get Set public string Password Get Set public int MaxClients Get Set"},{"location":"api_reference/#methods_48","title":"Methods","text":"Method Parameters Description public ServerDiscover GetServerDiscovererOverrides public void StartHostOverrides int magicNumber public void StartServerOverrides public void StartClientOverrides int magicNumber public void CloseOverrides public IClientConnectionInfo GetClientInfoOverrides int id public int GetClientCountOverrides public IEnumerable&lt;IClientConnectionInfo&gt; GetClientsOverrides public void ClientDisconnectOverrides string reason public void ServerDisconnectOverrides int idstring reason public void SendClientPacketOverrides IPacket packetbool reliable = false public void SendServerPacketOverrides IPacket packetint target = -1bool reliable = false"},{"location":"api_reference/#udpserverdiscoverer","title":"UDPServerDiscoverer","text":"Class NetBuff.Discover.UDPServerDiscoverer"},{"location":"api_reference/#implements_37","title":"Implements","text":"NetBuff.Discover.ServerDiscover&lt;T&gt;"},{"location":"api_reference/#methods_49","title":"Methods","text":"Method Parameters Description public void SearchOverrides Action&lt;UDPGameInfo&gt; onFindServerAction onFinish public void CancelOverrides"},{"location":"api_reference/#vector2networkvalue","title":"Vector2NetworkValue","text":"Class NetBuff.Misc.Vector2NetworkValue"},{"location":"api_reference/#implements_38","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_50","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#vector3networkvalue","title":"Vector3NetworkValue","text":"Class NetBuff.Misc.Vector3NetworkValue"},{"location":"api_reference/#implements_39","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_51","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"api_reference/#vector4networkvalue","title":"Vector4NetworkValue","text":"Class NetBuff.Misc.Vector4NetworkValue"},{"location":"api_reference/#implements_40","title":"Implements","text":"NetBuff.Misc.NetworkValue&lt;T&gt;"},{"location":"api_reference/#methods_52","title":"Methods","text":"Method Parameters Description public void SerializeOverrides BinaryWriter writer public void DeserializeOverrides BinaryReader reader"},{"location":"components/","title":"Components","text":"<p>The image below presents a scheme with the main network components of NetBuff:</p> <p></p> <p>To develop your project, it is necessary to first understand the main functionalities of each part of the system. In the sections below, you can find information about each of the basic components.</p>"},{"location":"components/#network-manager","title":"Network Manager","text":"<p>The NetworkManager component is the main component of the system, responsible for controlling the state of objects, packet delivery, and data synchronization between clients and the server, as well as controlling the initialization of network parts.</p> <p></p>"},{"location":"components/#network-manager-gui","title":"Network Manager GUI","text":"<p>The NetworkManagerGUI component is created to facilitate initial system testing. It creates a user interface with basic controls as well as statistics about the current connection.</p> <p></p> <p>Warning</p> <p>Using this component in a production environment is not recommended.</p>"},{"location":"components/#network-identity","title":"Network Identity","text":"<p>The NetworkIdentity component is used for the system to maintain references to objects in all network environments, that is, for the system to synchronize an object even on different machines. Every synchronized object needs to have a NetworkIdentity. In the inspector, the NetworkId of the identity is displayed, which is internally composed of 2 Int16 (totaling 32 bits), displayed as a string of 16 hexadecimal characters.</p> <p></p>"},{"location":"components/#ownership","title":"Ownership","text":"<p>Each NetworkIdentity is owned by some part of the network. The NetworkIdentity.OwnerId property stores the information about who is the current owner of the object, indicating the id of the client that has control over the object's state. By default, the value of NetworkIdentity.OwnerId is -1, indicating that the object is owned by the server. You can use the NetworkIdentity.IsOwnedByClient property to check if the object is owned by a client or not.</p> <p>The NetworkIdentity.HasAuthority property is used to check if the local environment (whether client, server, or host) has authority to modify the object in question, where some actions such as activating/deactivating or even changing the owner of the object require authority.</p> <pre><code>if (!HasAuthority)\n    return;\n\n//Transfer the ownership back to the server\nif(Input.GetKeyDown(KeyCode.S))\n    SetOwner(-1);\n</code></pre> <p>Tip</p> <p>Before performing any action on an object, remember to check the authority. In the case of a PlayerController, for example, only the owner of the object should have control over it.</p> <p>Warning</p> <p>When a client disconnects from the server, all objects controlled by it (NetworkIdentity.GetNetworkObjectsOwnedBy) are automatically despawned. You can use the NetworkBehaviour.OnClientDisconnected callback on the server to change the ownership of the object to avoid them being destroyed:</p> <pre><code>public override void OnClientDisconnected(int clientId)\n{\n    if (clientId == OwnerId)\n        ForceSetOwner(-1); //Sets the owner even without authority (Server-Only)\n}\n</code></pre>"},{"location":"components/#finding-objects","title":"Finding Objects","text":"<p>There are several ways to locate a NetworkIdentity, the main one being using the NetworkId through the NetworkIdentity.GetNetworkObject method. It is also possible to use the NetworkIdentity.GetNetworkObjectsOwnedBy method to find all objects owned by a certain client, or the NetworkIdentity.GetNetworkObjects method to return all registered NetworkIdentity objects.</p> <p>Tip</p> <p>Calling the NetworkIdentity.GetNetworkObjectsOwnedBy method with ownerId = -1, it is possible to find all objects owned by the server.</p>"},{"location":"components/#spawning-objects","title":"Spawning Objects","text":"<p>You can spawn NetworkIdentity objects using the NetworkIdentity.Spawn method using the prefab. At the time of spawn, it is also possible to configure the object in various ways:</p> <pre><code>Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true);\n</code></pre> <p>You can check which prefab was used to spawn an object by accessing the NetworkIdentity.PrefabId property. If an object was created in real-time, this value will be different from NetworkId.Empty. Pre-existing objects (created in the editor), even if they originated from a registered prefab, will not have a reference to the prefab.</p> <p>Tip</p> <p>When you spawn an object, you can choose who will own the object. If the field is omitted, the default value is -1, meaning the ownership of the NetworkIdentity will be of the server.</p> <p>Tip</p> <p>When you spawn an object, you can choose in which scene the object will appear. If the field is omitted, the default value is -1, meaning the object will go to the last loaded scene. See the Scene Management section for more information.</p> <p>Warning</p> <p>Remember to register your prefabs in the NetworkPrefabRegistry, otherwise, the system will not be able to spawn objects remotely. If the prefab is not registered, an error will occur. You can use the editor tool located in the NetBuff/Check Prefab Registries menu to check if there is any problem with your NetworkPrefabRegistry.</p>"},{"location":"components/#despawning-objects","title":"Despawning Objects","text":"<p>To despawn an object, simply use the NetworkIdentity.Despawn method. It is only possible to remove an object if the local server/client has authority over the object. If necessary, the server can use the NetworkIdentity.ForceSetOwner method first to gain permission to despawn the object.</p> <pre><code>ForceSetOwner(-1);\nDespawn();\n</code></pre>"},{"location":"components/#activating-deactivating-objects","title":"Activating / Deactivating Objects","text":"<p>During an object's existence, it's also possible to change its activation state using the method NetworkIdentity.SetActive. Changing an object's activation state is only possible if the local server/client has authority over the object. If necessary, the server can use the method NetworkIdentity.ForceSetOwner beforehand to gain permission to despawn the object.</p> <pre><code>ForceSetOwner(-1);\nSetActive(true);\n</code></pre>"},{"location":"components/#network-prefab-registry","title":"Network Prefab Registry","text":"<p>For NetBuff to be able to spawn objects over the network, it's necessary to maintain references to prefabs between clients and the server. Therefore, all prefabs that will be used to spawn objects in real-time (players, enemies, projectiles, etc.) must be registered in a NetworkPrefabRegistry, which should be referenced in the NetworkManager. Through the NetworkManager.PrefabRegistry property, you can reference which NetworkPrefabRegistry is being used.</p> <p></p> <p>Tip</p> <p>You can use the editor tool located in the NetBuff/Check Prefab Registries menu to check if there are any issues with your NetworkPrefabRegistry.</p>"},{"location":"components/#network-behaviour","title":"Network Behaviour","text":"<p>The NetworkBehaviour component serves as the basis for all other network components that are attached to a NetworkIdentity. They are primarily responsible for synchronizing an object's state and handling/controlling its behaviors. Unlike normal MonoBehaviours, they cannot be added/removed in real-time. Much of the logic in a project created using NetBuff will be contained in components implemented using NetworkBehaviour as a base.</p> <p></p> <p>Tip</p> <p>All properties and methods of the NetworkIdentity class have an interface in the NetworkBehaviour class to facilitate development.</p> <pre><code>public class MyNetworkBehaviour : NetworkBehaviour\n{\n    public void MyMethod()\n    {\n        //Instead of doing this\n        Identity.SetActive(false);\n\n        //You can do this\n        SetActive(false);\n    }\n}\n</code></pre> <p>Some NetworkBehaviour are already implemented by default:</p>"},{"location":"components/#network-transform","title":"Network Transform","text":"<p>The NetworkTransform component is used to synchronize the state of a transform over the network. You can set the update rate and which components will be updated, reducing the required data transfer rate.</p> <p></p> <p>Warning</p> <p>Changing which fields will be synchronized (i.e., NetworkTransform.SyncModeMask) should not be done in real-time.</p>"},{"location":"components/#network-rigidbody-transform","title":"Network Rigidbody Transform","text":"<p>The NetworkRigidbodyTransform component functions similarly to the NetworkTransform component but also synchronizes the object's velocity, angular velocity, and the Rigidbody.IsKinematic property, improving the synchronization of physics-enabled objects.</p> <p></p> <p>Warning</p> <p>Changing which fields will be synchronized (i.e., NetworkTransform.SyncModeMask) should not be done in real-time.</p>"},{"location":"components/#network-animator","title":"Network Animator","text":"<p>The NetworkAnimator component is used to synchronize the state of an Animator, including its parameters, layer weights, and animation/transition times.</p> <p></p> <p>Warning</p> <p>Due to the functioning of the Animator.SetTrigger function, automatic synchronization is not possible. Use the NetworkAnimator.SetTrigger method to properly synchronize the state.</p>"},{"location":"components/#network-value","title":"Network Value","text":"<p>The simplest way to customize the states of a NetworkBehaviour is by using a NetworkValue attached to it:</p> <p></p> <p>Tip</p> <p>All NetworkValues have a yellow name in the inspector to make differentiation easier.</p> <p>Tip</p> <p>For testing purposes, you can change the value of any NetworkValue through the inspector, even without having authority.</p> <pre><code>public class CustomBehaviour : NetworkBehaviour\n{\n    //Only the NetworkIdentity owner can modify this value\n    public ColorNetworkValue color = new ColorNetworkValue(Color.white);\n\n    //Only the server can modify this value\n    public IntNetworkValue team = new IntNetworkValue(2, NetworkValue.ModifierType.Server);\n\n    private void OnEnable()\n    {\n        //Register values\n        WithValues(color, team);\n    }\n\n    private void Update()\n    {\n        if(!HasAuthority)\n            return;\n\n        if(Input.GetKeyDown(KeyCode.Space))\n            team.Value ++;   \n    }\n}\n</code></pre>"},{"location":"components/#supported-types","title":"Supported Types","text":"<p>Below is a list of all supported types of NetworkValue by default:</p> <ul> <li>Bool</li> <li>Byte</li> <li>Int</li> <li>Float</li> <li>Double</li> <li>Long</li> <li>Short</li> <li>String</li> <li>Vector2</li> <li>Vector3</li> <li>Vector4</li> <li>Quaternion</li> <li>Color</li> <li>NetworkId</li> </ul>"},{"location":"components/#custom-type-support","title":"Custom Type Support","text":"<p>If necessary, you can implement your own NetworkValue. In the following example, we can see the implementation of a FloatArrayNetworkValue:</p> <pre><code>[Serializable]\npublic class FloatArrayNetworkVariable : NetworkValue&lt;float[]&gt;\n{\n    public FloatArrayNetworkVariable(float[] defaultValue, ModifierType type = ModifierType.OwnerOnly) : base(defaultValue, type) {}\n    public override void Serialize(BinaryWriter writer)\n    {\n        writer.Write(Value.Length);\n        for (var i = 0; i &lt; Value.Length; i++)\n            writer.Write(Value[i]);\n    }\n\n    public override void Deserialize(BinaryReader reader)\n    {\n        var length = reader.ReadInt32();\n        Value = new float[length];\n        for (var i = 0; i &lt; length; i++)\n            Value[i] = reader.ReadSingle();\n    }\n}\n\npublic class SceneLoadingSimplePlayer : NetworkBehaviour\n{\n    public FloatArrayNetworkVariable justAValue = new FloatArrayNetworkVariable(new float[10]);\n}\n</code></pre>"},{"location":"components/#listening-for-changes","title":"Listening For Changes","text":"<p>To facilitate, the NetworkValue&lt;T&gt; class has the OnValueChanged callback, which is called when the value of the NetworkValue changes (locally or externally), which is useful for creating reactive systems, such as a point counter on the screen that should update whenever the number of points changes.</p> <pre><code>public class PlayerController : NetworkBehaviour\n{\n    public StringNetworkValue nickname = new StringNetworkValue(\"\");\n    public TMP_Text headPlate;\n\n    public void OnEnable()\n    {\n        WithValues(nickname);\n\n        nickname.OnValueChanged += (oldValue, newValue) =&gt;\n        {\n            headPlate.text = newValue;\n        };\n    } \n}\n</code></pre>"},{"location":"components/#modifier-type","title":"Modifier Type","text":"<p>Each NetworkValue can have its own modification permissions, regardless of the ownership of the NetworkIdentity of the object.</p> <pre><code>//Only the NetworkIdentity owner can modify this value\npublic ColorNetworkValue color = new ColorNetworkValue(Color.white);\n\n//Only the server can modify this value\npublic IntNetworkValue team = new IntNetworkValue(2, NetworkValue.ModifierType.Server);\n</code></pre> <p>Warning</p> <p>Do not change the modification permissions of a variable in real-time. If necessary, set it to ModifierType.Everybody.</p>"},{"location":"custom_behaviours/","title":"Creating Custom Behaviours","text":"<p>To implement the logic of your project, you'll need to implement your own NetworkBehaviours. Below you can find the basic structure of a NetworkBehaviour and its components:</p> <pre><code>public class CustomNetworkBehaviour : NetworkBehaviour\n{\n    //My Fields\n    public float walkSpeed = 3f;\n\n    //My Network Values\n    public IntNetworkValue team = new IntNetworkValue(0);\n\n    //Unity callbacks\n    public void OnEnable(){}\n\n    //Network callbacks\n    public override void OnSpawned(bool isRetroactive){}\n}\n</code></pre> <p>Tip</p> <p>A NetworkBehaviour works exactly like a normal MonoBehaviour while also providing state synchronization over the network.</p> <p>Warning</p> <p>It's not possible to remove and/or add a NetworkBehaviour in real-time.</p>"},{"location":"custom_behaviours/#custom-serialization","title":"Custom Serialization","text":"<p>If your NetworkBehaviour has a state that's too complex to synchronize using only NetworkValue, you can use custom serialization. Simply implement the INetworkBehaviourSerializer interface in your NetworkBehaviour:</p> <pre><code>public class CustomNetworkBehaviour : NetworkBehaviour, INetworkBehaviourSerializer\n{\n    public float[] valueTooComplex = new float[0];\n\n    public void OnSerialize(BinaryWriter writer, bool forceSendAll)\n    {\n        writer.Write(valueTooComplex.Length);\n        for (var i = 0; i &lt; valueTooComplex.Length; i++)\n        {\n            writer.Write(valueTooComplex[i]);\n        }   \n    }\n\n    public void OnDeserialize(BinaryReader reader)\n    {\n        var length = reader.ReadInt32();\n        valueTooComplex = new float[length];\n        for (var i = 0; i &lt; length; i++)\n        {\n            valueTooComplex[i] = reader.ReadSingle();\n        }\n    }\n}\n</code></pre> <p>By doing this, all data will be synchronized over the network (even if someone connects later). If the data is too complex (like that of NetworkTransform), you can implement a system to update only the necessary data, and when the forceSendAll parameter is true, all data must be synchronized. This parameter will only be true when a client connects later.</p> <p>Warning</p> <p>These values are not re-updated automatically. You should use the NetworkBehaviour.MarkSerializerDirty method to trigger serialization and, consequently, deserialization (with forceSendAll = false).</p>"},{"location":"custom_behaviours/#custom-packets","title":"Custom Packets","text":"<p>The third (and most optimized) method to synchronize custom data is by creating packets. Internally, both of the other two methods use packets to synchronize data, and even the basic functioning of the network is based on packets.</p> <p>The packet-based system was chosen as the main transfer method for NetBuff because it's lightweight, fast, and highly customizable. To create a custom packet, you need to create a class that implements the IPacket or IOwnedPacket interface:</p> <pre><code>public class PlayerPunchActionPacket : IPacket\n{\n    public NetworkId Id { get; set; }\n\n    public void Serialize(BinaryWriter writer)\n    {\n        Id.Serialize(writer);\n    }\n\n    public void Deserialize(BinaryReader reader)\n    {\n        Id = NetworkId.Read(reader);\n    }\n}\n\npublic class PacketBodyRotation : IOwnedPacket\n{\n    public NetworkId Id { get; set; }\n    public float BodyRotation { get; set; }\n\n    public void Serialize(BinaryWriter writer)\n    {\n        Id.Serialize(writer);\n        writer.Write(BodyRotation);\n    }\n\n    public void Deserialize(BinaryReader reader)\n    {\n        Id = NetworkId.Read(reader);\n        BodyRotation = reader.ReadSingle();\n    }\n}\n</code></pre> <p>A IOwnedPacket is an IPacket that is directly linked to a NetworkIdentity, therefore, they will be internally sent by a NetworkBehaviour, and the server will find the same NetworkBehaviour in other network points and call the receiving callback.</p> <p>A normal IPacket is not directly linked to anything, so they will simply be sent over the network, and all handling must be done manually.</p>"},{"location":"custom_behaviours/#sending-packets","title":"Sending Packets","text":"<p>To send a packet, simply use the NetworkBehaviour.SendPacket method, which will send the packet using the correct method automatically:</p> <pre><code>var packet = new PacketBodyRotation\n{\n    Id = Id,\n    BodyRotation = body.localEulerAngles.y\n};\nSendPacket(packet);\n</code></pre> <p>Internally, the system automatically chooses between the NetworkBehaviour.ClientSendPacket and NetworkBehaviour.ServerBroadcastPacket methods depending on whether the local environment is a client or server:</p> <pre><code>if (IsOwnedByClient)\n    ClientSendPacket(packet, reliable); //Client sends a message to the server\nelse\n    ServerBroadcastPacket(packet, reliable); //Server broadcast a message to all the clients\n</code></pre> <p>The server can also use the NetworkBehaviour.ServerSendPacket method to send a packet to a single client or the NetworkBehaviour.ServerBroadcastPacketExceptFor method to send to all clients except one.</p>"},{"location":"custom_behaviours/#receiving-owned-packets","title":"Receiving Owned Packets","text":"<p>To receive IOwnedPackets, you can use the NetworkBehaviour.OnServerReceivePacket and NetworkBehaviour.OnClientReceivePacket callbacks:</p> <pre><code>public class PlayerController : NetworkBehaviour\n{\n    //Server received the packet, check the ownership (optional) then broadcasts it to everyone else than the origin client\n    public override void OnServerReceivePacket(IOwnedPacket packet, int clientId)\n    {\n        switch (packet)\n        {\n            case PacketBodyRotation data:\n                if(clientId == OwnerId)\n                    ServerBroadcastPacketExceptFor(data, clientId);\n                break;\n        }\n    }\n\n\n    //Client received the packet, then applied it to the transform itself\n    public override void OnClientReceivePacket(IOwnedPacket packet)\n    {\n        switch (packet)\n        {\n            case PacketBodyRotation bodyRot:\n                transform.eulerAngles = new Vector3(0, bodyRot.BodyRotation, 0);\n                break;\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>Only the object with the IOwnedPacket.Id will receive the callbacks, so you don't need to worry about checking the id manually!</p>"},{"location":"custom_behaviours/#receiving-not-owned","title":"Receiving Not Owned","text":"<p>If a packet is not owned, you can register a custom listener for it anywhere in the project. In the example below, the Lever class is listening for PlayerPunchActionPacket, which is a packet sent by the PlayerController class:</p> <pre><code>public class Lever : NetworkBehaviour\n{\n    public BoolNetworkValue isOn = new(false);\n    public float radius = 2f;\n\n    private void OnEnable()\n    {\n        WithValues(isOn);\n        GetPacketListener&lt;PlayerPunchActionPacket&gt;().OnServerReceive += OnPlayerPunch;\n        //GetPacketListener&lt;PlayerPunchActionPacket&gt;().OnClientReceive ...;\n    }\n\n    private void OnDisable()\n    {\n        GetPacketListener&lt;PlayerPunchActionPacket&gt;().OnServerReceive -= OnPlayerPunch;\n    }\n\n    private void OnPlayerPunch(PlayerPunchActionPacket obj, int client)\n    {\n        var o = GetNetworkObject(obj.Id);\n        var dist = Vector3.Distance(o.transform.position, transform.position);\n\n        if (dist &gt; radius)\n            return;\n\n        isOn.Value = !isOn.Value;\n    }\n}\n\npublic class PlayerController : NetworkBehaviour\n{\n    private void Update()\n    {\n        if (!HasAuthority)\n            return;\n\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            SendPacket(new PlayerPunchActionPacket { Id = Id }, true);\n        }\n    }\n}\n</code></pre>"},{"location":"custom_behaviours/#packet-reliability","title":"Packet Reliability","text":"<p>When you use any of the packet sending methods, you can set the reliability argument. When set to true, the delivery method is reliable, supporting larger packets at the cost of being slightly slower. When set to false, there's no reliability, packets are limited to small sizes, but delivery is extremely fast!</p> <p>Synchronization of NetworkValue and any other important/instantaneous actions are done using reliable delivery because they need to be guaranteed. NetworkTransform, on the other hand, doesn't use reliable delivery because its state is updated almost constantly, so losing some packets probably won't cause issues.</p> <p>Packet loss can be seen using the NetworkManagerGUI. If the network connection quality is good, you might not lose any packets, but if you have network issues, you might experience some packet loss. Choose wisely when reliability is needed or not. Most of the time, it's better to use reliable=true.</p> Unreliable Reliable Speed Fast+ Fast Max Size Small Large Order Can be unordered Order will be maintained Loss Can be lost If lost, they will be resent Example Usage NetworkTransform, high-frequency update packets Actions, NetworkValues, etc..."},{"location":"custom_behaviours/#network-callbacks","title":"Network Callbacks","text":"<p>Tip</p> <p>See the API reference of the NetworkBehaviour class for the list of all properties and methods.</p>"},{"location":"custom_network_manager/","title":"Custom Network Manager","text":"<p>Sometimes, the default implementation of the network manager may not meet all your needs. We recommend creating your own implementation of the NetworkManager to fit your project's requirements. In the following example, there's a custom implementation of the NetworkManager where we override the NetworkManager.OnSpawnPlayer method to meet the needs of our project (Solis):</p> <pre><code>public class SolisNetworkManager : NetworkManager\n{\n    public GameObject robotPrefab;\n    public Transform robotSpawnPoint;\n    public Transform humanSpawnPoint;\n\n    private void Awake()\n    {\n        if (Instance == this || Instance == null) DontDestroyOnLoad(this.gameObject);\n        else Destroy(this.gameObject);\n    }\n\n    protected override void OnSpawnPlayer(int clientId)\n    {  \n        var prefab = clientId == 0 ? playerPrefab : robotPrefab;\n        var t = clientId == 0 ? humanSpawnPoint : robotSpawnPoint;\n        Assert.IsTrue(prefabRegistry.IsPrefabValid(prefab), \"Player prefab is not valid\");\n        SpawnNetworkObjectForClients(prefabRegistry.GetPrefabId(prefab), t.position, t.rotation, t.localScale, clientId);\n    }\n}\n</code></pre>"},{"location":"custom_network_manager/#network-callbacks","title":"Network Callbacks","text":"<p>Tip</p> <p>See the API reference of the NetworkManager class for the list of all properties and methods.</p>"},{"location":"discoverer/","title":"Server Discoverer","text":"<p>The server discovery system helps clients find available servers to join. The server discoverer will return a GameInfo for each of the servers found.</p>"},{"location":"discoverer/#password-check-and-magic-number","title":"Password Check and Magic Number","text":"<p>The server owner can protect the game using a password, set in the NetworkTransport. When a client requests to join the server, the password must be provided (the transport should perform the verification, as the UDPNetworkTransport does).</p> <p>The magic number is a unique number for each project, defined in NetworkManager.VersionMagicNumber. You can change it whenever you want to make a version incompatible with others. When a client requests to join the server, the magic number must be provided (the transport should perform the verification, as the UDPNetworkTransport does).</p>"},{"location":"discoverer/#udp-server-discoverer","title":"UDP Server Discoverer","text":"<p>The UDPServerDiscoverer is a class used to find all available servers across all your networks. This method will call a callback whenever it finds a new server, returning a UDPGameInfo containing the remote server's IP address along with the standard GameInfo fields.</p> <pre><code>var discoverer = new UDPServerDiscoverer(NetworkManager.Instance.versionMagicNumber, udp.port);\ndiscoverer.Search((info) =&gt;\n{\n    list.Add(info);\n    _serverList = list.ToArray();\n}, \n() =&gt; \n{ \n    Debug.Log(\"Done!\");\n});\n\n//discoverer.Cancel();\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>In the following sections, you'll find guidance on setting up a NetBuff project. We recommend using Unity 2023.2 or a newer version.</p>"},{"location":"getting_started/#installation-guide","title":"Installation Guide","text":"<ol> <li>Go to the Unity Package Manager (Window -&gt; Package Manager).</li> <li>Click the \"+\" button in the top-left corner of the window.</li> <li>Select \"Add package from git URL...\".</li> <li>Paste the link below and click \"Add\".</li> <li>That's it! Now the package is installed. You can also download samples if you wish.</li> </ol> <pre><code>https://github.com/buff-buff-studio/NetBuff-Lib.git#package\n</code></pre>"},{"location":"getting_started/#network-setup","title":"Network Setup","text":"<p>Create an empty scene to begin with. We recommend using the Basic (Built-In) template:</p> <p></p> <p>Now, create a new GameObject and add the following components to it:</p> <ul> <li>NetworkManager</li> <li>NetworkManagerGUI</li> <li>UDPNetworkTransport</li> </ul> <p></p>"},{"location":"getting_started/#network-manager","title":"Network Manager","text":"<p>The NetworkManager is the main networking component. It manages connections, objects, packets, and everything else related to networking, being a singleton component in the networking setup.</p>"},{"location":"getting_started/#network-manager-gui","title":"Network Manager GUI","text":"<p>The NetworkManagerGUI is a temporary component used for testing purposes. It creates a menu where you can manage network connection, find all servers on the network, and see network statistics.</p>"},{"location":"getting_started/#udp-network-transport","title":"UDP Network Transport","text":"<p>The UDPNetworkTransport is the basic transport used to establish server-client connections over the internet.</p>"},{"location":"getting_started/#set-network-transport","title":"Set Network Transport","text":"<p>Now we need to set the network transport in the network manager. Simply drag and drop the transport onto the transport field of the manager:</p> <p></p>"},{"location":"getting_started/#creating-the-player-prefab","title":"Creating the player prefab","text":"<p>If you start the game and try to host a server, you'll see an error in the console. By default, we need to provide a player prefab to the NetworkManager to spawn the player object. Following the steps below, we can create a simple player prefab:</p> <ol> <li>Create a new capsule.</li> <li>Add a NetworkTransform component.</li> <li>Drag it as a prefab into the Project View.</li> <li>Delete it from the scene.</li> </ol>"},{"location":"getting_started/#creating-the-prefab-registry","title":"Creating the prefab registry","text":"<p>Now you're one step away from success! Even if you set the player prefab, all networking ends must know which prefab the server is trying to spawn, so we need to set up our NetworkPrefabRegistry first.</p> <ol> <li>Create a new NetworkPrefabRegistry in the Project Folder context menu.</li> <li>Add the prefab to the registry list (Click the + button to add a new slot to the registry).</li> <li>Click the N button to generate a new ID.</li> <li>Set it in the registry field of the NetworkManager.</li> <li>Set the player prefab in the player prefab field of the NetworkManager.</li> </ol> <p></p>"},{"location":"getting_started/#done","title":"Done!","text":"<p>Now we're ready! You can click the play button and then click Start Host to start hosting (Client + Server).</p> <p></p>"},{"location":"getting_started/#simple-movement-test","title":"Simple Movement Test","text":"<p>By creating a simple script, we can test our server. You can use the code below or create your own logic!</p> <pre><code>using NetBuff.Components;\nusing UnityEngine;\n\nnamespace Samples.Docs\n{\n    public class BasicMovement : NetworkBehaviour\n    {\n        private void Update()\n        {\n            if (!HasAuthority)\n                return;\n\n            var move = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\"));\n            transform.position += move * Time.deltaTime * 3;\n        }\n    }\n}   \n</code></pre> <p>Add it to the player and run the game again! You can even build and join the server as a client because your multiplayer game is already working!</p> <p></p>"},{"location":"network_testing/","title":"Testing the Network","text":"<p>We recommend using the Multiplayer Player Mode package to test your game in the editor without the need to build each time. Alternatively, you can simply build and run your project. With the fast reload system, you can edit your code in real-time, and your server's state will be maintained seamlessly, allowing you to adjust values or test/debug systems without the need to rebuild your project every time.</p> <p>The default transport method of NetBuff is UDP. By using the UDPNetworkTransport, you can test your game by connecting multiple clients (editors and builds) with just one click!</p> <p>We recommend using Clumsy to simulate delays and packet loss between your network connections to see where your projects need more optimization/cleanup. Clumsy is a free tool that can simulate delays, packet loss, out-of-order delivery, and more:</p> <p></p> <p>Tip</p> <p>By using the out-of-order delivery/packet loss feature, you can check if some of your packets being sent unreliably should be changed to the reliable method and check for any issues in network state synchronization.</p>"},{"location":"object_spawning/","title":"Spawning Objects","text":"<p>There are two types of NetworkIdentity objects: pre-existing and dynamically spawned. Using the NetworkIdentity.PrefabId field, you can check whether an object is pre-existing or not. If the PrefabId is empty, the object hasn't been dynamically spawned. Otherwise, the PrefabId will store the NetworkId of the prefab used to create that object. It's crucial for the server to know how to recreate the server state when a player connects later on.</p> <p>You can spawn a NetworkObject using the static method NetworkIdentity.Spawn:</p> <p><pre><code>if(Input.GetMouseButtonDown(0))\n{\n    Spawn(shotPrefab, cameraTransform.position + cameraTransform.forward * 1, cameraTransform.rotation, Vector3.one * 0.5f, true);\n}\n</code></pre> And there you go! With one line of code, your game object is spawned across the network. Just remember to ensure that your prefab is registered in the NetworkPrefabRegistry. You can also use the NetBuff/Check Prefab Registries if there are any issues with your registries:</p> <p></p>"},{"location":"object_spawning/#spawning-parameters","title":"Spawning Parameters","text":"<p>Below is a list of all the parameters you can set on a NetworkIdentity object spawn:</p> Parameter Type Description Owner int Represents the ownership id of the object. Default is -1 (Server) Position Vector3 Position of the object in the world Rotation Quaternion Rotation of the object in the world Scale Vector3 Scale of the object Active bool Object's activity state SceneId int Represents the destination scene id. Default is -1 (Last loaded scene) <p>Warning</p> <p>The scene id is the only complex parameter. By default, it's set to -1, so the NetworkIdentity object will be spawned in the currently last loaded scene. If the value is set to any other value, it will be set to the corresponding loaded scene. Scene id 0 always points to the main scene where the NetworkManager is located.</p> <p>Refer to the Scene Management page for more information on the scene system.</p>"},{"location":"reconnection_and_hot_reload/","title":"Reconnection and Hot-Reload","text":"<p>NetBuff supports mid/end-game connections seamlessly: Each NetworkIdentity from every scene will be synchronized, maintaining its values and additional serialized data. Even in the editor, you can edit the code, recompile the project, and the server will seamlessly maintain its state (clients will need to reconnect, but even their player objects will be kept in the same state without data loss).</p> <p>To keep the system running, you must ensure that the object state values are synchronized over the network, either using NetworkValues or utilizing callbacks from the INetworkBehaviourSerializer interface. If you need additional synchronization, you can also request a custom package in the NetworkBehaviour.OnSpawned callback, using the isRetroactive parameter to check if it's a late synchronization or not.</p> <p>Tip</p> <p>We strongly recommend that after every significant modification/addition to the system, developers perform the following checks:</p> <ol> <li>Hot-Reload functionality still works with your system.</li> <li>Players who connect mid/end-game do not encounter issues synchronizing the state of your game.</li> </ol> <p>These two checks ensure you won't have network state synchronization problems, and every client/player will be able to synchronize the game state seamlessly. Hot-Reload isn't necessary but can expedite network testing (in addition to demonstrating the application of best practices), as you can modify the code and NetworkValues via the inspector without losing the current server state.</p>"},{"location":"samples/","title":"Samples \ud83d\udd1c","text":"<p>Stay tuned for exciting samples and demonstrations! We're currently working on providing you with a variety of examples to help you better understand our features and functionalities. From basic implementations to advanced techniques, our samples will cover a wide range of topics to suit your needs. Check back later for updates!</p>"},{"location":"scene_management/","title":"Scene Management","text":"<p>NetBuff supports real-time scene loading/unloading, enabling more complex flows like level loading, among others. Every NetworkIdentity has the field NetworkIdentity.SceneId which indicates in which loaded scene the object resides.</p>"},{"location":"scene_management/#scene-id-rules","title":"Scene Id Rules","text":"<p>The scene where the NetworkManager is considered the main scene and receives the id 0, always being the first scene in the NetworkManager.LoadedScenes list, which stores all currently loaded scenes. A scene's id is defined by its index in the list and can vary according to the loading/unloading order of scenes.</p> <p>Note</p> <p>The scene id -1 is the default and always refers to the last currently loaded scene (NetworkBehaviour.LastLoadedScene). Objects are spawned in this scene by default if the scene parameter is omitted.</p> <p>Warning</p> <p>It's recommended to use the scene name as a persistent way to reference a scene. You can use the methods NetworkBehaviour.GetSceneName and NetworkBehaviour.GetSceneId to convert between name and id.</p>"},{"location":"scene_management/#loading-and-unloading-scenes","title":"Loading and Unloading Scenes","text":"<p>To load a scene, simply use the NetworkManager.LoadScene method, and to unload, use the NetworkManager.UnloadScene method.</p> <pre><code>if (NetworkManager.Instance.IsSceneLoaded(scene1))\n    NetworkManager.Instance.UnloadScene(scene1);\nelse\n    NetworkManager.Instance.LoadScene(scene1);\n</code></pre> <p>Warning</p> <p>It's not possible to unload the main scene where the NetworkManager resides.</p> <p>Note</p> <p>Only the server can load/unload scenes, but all scenes are synchronized for clients, and all other scene control-related methods and properties work as usual.</p>"},{"location":"scene_management/#moving-objects-between-scenes","title":"Moving Objects Between Scenes","text":"<p>It's possible to move a NetworkIdentity between scenes using the NetworkIdentity.MoveToScene method.</p> <pre><code>public void Update()\n{\n    if(!HasAuthority)\n        return;\n\n    if (Input.GetKeyDown(KeyCode.M))\n    {\n        var id = SceneId + 1;\n        if (id &gt;= LoadedSceneCount)\n            id = 0;\n\n        //Moves the object to the next loaded scene\n        MoveToScene(id);\n    }\n}\n</code></pre> <p>Warning</p> <p>You need to have control over the NetworkIdentity to move it between scenes.</p>"},{"location":"transports/","title":"Network Transport","text":"<p>The NetworkTransport is a base class used to define how communication between network endpoints will be handled. You can implement your own transport to support any kind of connection protocol you desire, such as Bluetooth, etc...</p> <pre><code>public abstract class NetworkTransport : MonoBehaviour\n{\n    #region ManagementMethods\n    public abstract void StartHost(int magicNumber);\n    public abstract void StartServer();\n    public abstract void StartClient(int magicNumber);\n    public abstract void Close();\n    #endregion\n\n    #region Client Methods\n    public abstract IClientConnectionInfo GetClientInfo(int id);\n    public abstract int GetClientCount();\n    public abstract IEnumerable&lt;IClientConnectionInfo&gt; GetClients();\n    #endregion\n\n    #region Lifecycle\n    public abstract void ClientDisconnect(string reason);\n    public abstract void ServerDisconnect(int id, string reason);\n    public abstract void SendClientPacket(IPacket packet, bool reliable = false);\n    public abstract void SendServerPacket(IPacket packet, int target = -1, bool reliable = false);\n\n    public void BroadcastServerPacket(IPacket packet, bool reliable = false)\n    {\n        SendServerPacket(packet, -1, reliable);\n    }\n    #endregion\n}\n</code></pre>"},{"location":"transports/#local","title":"Local","text":"<p>The LocalNetworkTransport is the most basic network transport method. With local network transport, you can add support for split-screen mode without any additional coding required (just manage player input separately): each action will be seamlessly handled, even locally.</p> <p></p>"},{"location":"transports/#udp","title":"UDP","text":"<p>UDP (User Datagram Protocol) is the primary gaming network protocol, thus it's the basic internet-based protocol supported. Currently, UDP connection is established using the LiteNetLib library, which provides custom reliability systems that fit our gaming needs perfectly.</p> <p></p> <p>In the UDPNetworkTransport component, you can set the host/remote address, host/remote port, connection password, and maximum server client limit.</p>"},{"location":"troubleshooting/","title":"Common Troubleshooting \ud83d\udd1c","text":"<p>Coming Soon! We understand that sometimes things don't go as planned, but worry not! We're compiling a comprehensive list of common issues and troubleshooting tips to assist you in overcoming any hurdles you may encounter. Whether it's network connectivity issues, setup problems, or anything in between, we've got you covered. Keep an eye out for updates!</p>"}]}